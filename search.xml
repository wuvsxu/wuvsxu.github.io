<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring cloud Alibaba]]></title>
    <url>%2F2020%2F06%2F23%2Fspring-cloud-Alibaba%2F</url>
    <content type="text"><![CDATA[OpenFeign远程调用中心（注册中心）向注册中心将微服务注册上去，以后本微服务需要使用其他服务的接口等，可以在本服务中写一个配置接口，路径就是其他服务的调用接口，直接使用该接口，就可以调用到这个服务。好处：实时的感知服务的上线，连通性 Nacos配置中心在微服务中经常会有很多的配置项，但是这些配置项如果有改动，经常需要去修改这个微服务的配置文件，然后重新启动，这样会很麻烦。在微服务将自己的服务注册到注册中心后，可以在注册中心发布一些配置项，发布成功后，微服务会自动读取这些配置项，修改该微服务的内存中，微服务会就不用重新部署和启动了。好处： 1.解决了微服务修改配置困难的问题 2.可以对不同环境下的配置进行管理，比如开发和测试环境的配置不同 3.简化配置，也可加载配置集，即在配置中心中增加多个配置文件]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装docker]]></title>
    <url>%2F2020%2F06%2F17%2Flinux%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[安装docker官方文档https://docs.docker.com/engine/install/centos/,按照以下步骤操作。 Uninstall old versions 12345678sudo yum remove docker \ docker-client \ docker-client-latest \ docker-common \ docker-latest \ docker-latest-logrotate \ docker-logrotate \ docker-engine Install using the repository 12345$ sudo yum install -y yum-utils$ sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo INSTALL DOCKER ENGINE 1$ sudo yum install docker-ce docker-ce-cli containerd.io 启动docker 1sudo systemctl start docker 设置成开机自启动 1sudo systemctl enable docker ps： 官方的镜像下载地址，&lt;hub.docker.com/search&gt;， 可以查看到docker的各种镜像 配置阿里云的docker镜像地址配置该项是为了以后下载docker时速度会很快。操作如下 登录到aliyun.com –&gt;右上角点 控制台 –&gt;左边菜单栏 产品与服务–&gt;容器镜像服务–&gt; 镜像加速器–&gt;右边选择centos 可以找到以下脚本。分别执行 123456789101112#1sudo mkdir -p /etc/docker#2sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;&#123; &quot;registry-mirrors&quot;: [&quot;https://u52e9dsr.mirror.aliyuncs.com&quot;]&#125;EOF#3sudo systemctl daemon-reload#4sudo systemctl restart docker docker安装mysql 连接上服务器 vagrant ssh 下载mysql镜像 sudo docker pull mysql:5.7 创建实例并启动123456docker run -p 3306:3306 --name mysql \-v /mydata/mysql/log:/var/log/mysql \-v /mydata/mysql/data:/var/lib/mysql \-v /mydata/mysql/conf:/etc/mysql \-e MYSQL_ROOT_PASSWORD=root \-d mysql:5.7 解释： -p 3306:3306 后一个3306是docker中mysql的端口，前一个3306是把后一个端口映射到linux服务器的3306端口–name mysql 给当前容器起的名字-v /mydata/mysql/log:/var/log/mysql 把docker下/var/log/mysql目录挂载到linux下/mydata/mysql/log目录，这样方便后续配置的修改，查看日志-e MYSQL_ROOT_PASSWORD=root 改变mysql的一些参数使用 docker exec -it mysql /bin/bash 就可以进入到mysql的docker容器内部 修改mysql的配置vi /mydata/mysql/conf/my.cnf12345678910111213[client]default-character-set=utf8[mysql]dafault-character-set=utf8[mysqld]init_connect=&apos;SET colletion_connection = utf8_unicode_ci&apos;init_connect=&apos;SET NAMES utf8&apos;character-set-server=utf8collation-server=utf8_unicode_ciskip-character-set-client-handshakeskip-name-resolve 解释：skip-name-resokve 跳过域名解析 docker安装redis 下载镜像 docker pull redis 创建文件夹（为下一步使用，如果直接执行下一步，创建出来的是文件夹，不是文件） 12mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.conf 创建实例并启动 1234docker run -p 6379:6379 --name redis \-v /mydata/redis/data:/data \-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \-d redis redis-server /etc/redis/redis.conf 修改配置，使redis数据持久化vi /mydata/redis/conf/redis.conf appendonly yes 重启docker restart redis ps ：redis的可视化工具，RedisDesktopManager]]></content>
      <tags>
        <tag>linux</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vagrant快速创建linux虚拟机]]></title>
    <url>%2F2020%2F06%2F16%2Fvagrant%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[创建linux虚拟机 将本机电脑的虚拟化技术打开。 下载virtualBoxhttps://www.vagrantup.com/downloads.html并安装，用于管理虚拟机。 下载vagranthttps://www.vagrantup.com/downloads.html,选择windows64版本，并安装。3.1 打开cmd命令行，输入vagrant,如果显示有提示信息，那么vagrant就安装好了3.2 选择一个目录下，输入 vagrant init centos/7 ,此时会在当前目录下创建一个Vagrantfile文件3.3 使用 vagrant up 命令，会在virtualBox中创建虚拟机，这个会从网上慢慢下载，需要等上一段时间，这个过程中会自动创建好ssh链接，并且启动3.4 使用 vagrant ssh 命令，会连接上这个在本地的虚拟机，此时登录的默认用户是vagrant PS: 1. vagrant的官方仓库https://app.vagrantup.com/boxes/search?page=1，我们需要的是Centos/7,这就是上面命令中Centos/7的由来 2. virtualBox可能与本机的360，红蜘蛛，净网大师冲突，需要卸载相关软件。 网络配置 打开Vagrantfile文件，找到config.vm.network “private_network”, ip: “192.168.33.11”,将这一行解注。 在命令行中输入ipconfig，查看网络，找到以太网络适配器 VirtualBox host-Only Network: 这个相关的IPV4地址，配置到第一行的ip中，将最后一位数字自己变化一下，不要写1就行。 重启虚拟机 vagrant reload 重启完成后，vagrant ssh连接上虚拟机， ip addr ,查看当前网络ip地址，就是自己配置的ip。可以在虚拟机和本机互相ping一下ip。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>vagrant</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[maven打包成可运行的jar]]></title>
    <url>%2F2020%2F06%2F12%2Fmaven%E6%89%93%E5%8C%85%E6%88%90%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%9A%84jar%2F</url>
    <content type="text"><![CDATA[有时我们需要开发可直接运行的jar包，直接使用maven对项目打包后，生成的jar，使用java -jar xxx.jar运行会出错，可能会有”no main manifest attribute, in xxx.jar”（没有设置Main-Class）、ClassNotFoundException（找不到依赖包）等错误。 这是由于我们没有设置启动的main方法，打包的时候，没有将依赖包打入到当前的jar内，要想解决上面的问题，需要以下步骤 1. 在pom文件中添加以下内容123456789101112131415161718&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;!-- 配置启动类 --&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2. 在当前项目的目录下执行以下命令1mvn assembly:assembly 此时在target目录下会生成jar，其中就包含了依赖的jar包。]]></content>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中getDate()和getDay()方法踩坑]]></title>
    <url>%2F2020%2F06%2F12%2Fjava%E4%B8%ADgetDate-%E5%92%8CgetDay-%E6%96%B9%E6%B3%95%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[今天在调试bug的时候发现根据时间获取当天的年月日不对，如下12Date now=new Date();Date day=new Date(now.getYear(),now.getMonth(),now.getDay()); 打印出来的日期是Fri Jun 05 00:00:00 CST 2020查找了下官方文档，描述如下int getDate() Deprecated. As of JDK version 1.1, replaced by Calendar.get(Calendar.DAY_OF_MONTH).int getDay() Deprecated. As of JDK version 1.1, replaced by Calendar.get(Calendar.DAY_OF_WEEK).其中getDate()方法获取的才是当月的第几天。getDay()获取的时本周的第几天。另外，查找了相关资料，总结了以下几个在java日期处理易踩的坑。 用Calendar设置时间的坑反例123Calendar c = Calendar.getInstance();c.set(Calendar.HOUR, 10);System.out.println(c.getTime()); 正例12Calendar c = Calendar.getInstance();c.set(Calendar.HOUR_OF_DAY, 10); 解析：我们设置了10小时，但运行结果是22点，而不是10点。因为Calendar.HOUR默认是按12小时制处理的，需要使用Calendar.HOUR_OF_DAY，因为它才是按24小时处理的。 Java日期格式化YYYY的坑反例：12345Calendar calendar = Calendar.getInstance();calendar.set(2019, Calendar.DECEMBER, 31);Date testDate = calendar.getTime();SimpleDateFormat dtf = new SimpleDateFormat(&quot;YYYY-MM-dd&quot;);System.out.println(&quot;2019-12-31 转 YYYY-MM-dd 格式后 &quot; + dtf.format(testDate)); 运行结果2019-12-31 转 YYYY-MM-dd 格式后 2020-12-31解析：YYY是基于周来计算年的，它指向当天所在周属于的年份，一周从周日开始算起，周六结束，只要本周跨年，那么这一周就算下一年的了。正确姿势是使用yyyy格式。正例：12345Calendar calendar = Calendar.getInstance();calendar.set(2019, Calendar.DECEMBER, 31);Date testDate = calendar.getTime();SimpleDateFormat dtf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);System.out.println(&quot;2019-12-31 转 yyyy-MM-dd 格式后 &quot; + dtf.format(testDate)); Java日期格式化hh的坑反例：1234String str = &quot;2020-03-18 12:00&quot;;SimpleDateFormat dtf = new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm&quot;);Date newDate = dtf.parse(str);System.out.println(newDate); 正例：1234String str = &quot;2020-03-18 12:00&quot;;SimpleDateFormat dtf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm&quot;);Date newDate = dtf.parse(str);System.out.println(newDate); 解析：hh是12制的日期格式，当时间为12点，会处理为0点。正确姿势是使用HH，它才是24小时制。 Calendar获取的月份比实际数字少1即(0-11)反例：123//获取当前月，当前是6月Calendar calendar = Calendar.getInstance();System.out.println(&quot;当前&quot;+calendar.get(Calendar.MONTH)+&quot;月份&quot;); 运行结果：当前5月份正例：123//获取当前月，当前是3月Calendar calendar = Calendar.getInstance();System.out.println(&quot;当前&quot;+(calendar.get(Calendar.MONTH)+1)+&quot;月份&quot;); 解析：The first month of the year in the Gregorian and Julian calendarsis JANUARY which is 0;也就是1月对应的是下标 0，依次类推。因此获取正确月份需要加 1. Java日期格式化DD的坑DD和dd表示的不一样，DD表示的是一年中的第几天，而dd表示的是一月中的第几天。 Java日期的夏令时问题反例：123TimeZone.setDefault(TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.parse(&quot;1986-05-04 00:30:00&quot;)); 运行结果：Sun May 04 01:30:00 CDT 1986解析：先了解一下夏令时:夏令时，表示为了节约能源，人为规定时间的意思。一般在天亮早的夏季人为将时间调快一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的国家具体规定不同。目前全世界有近110个国家每年要实行夏令时。1986年4月，中国中央有关部门发出“在全国范围内实行夏时制的通知”，具体作法是：每年从四月中旬第一个星期日的凌晨2时整（北京时间），将时钟拨快一小时。(1992年起，夏令时暂停实行。)夏时令这几个时间可以注意一下哈，1986-05-04, 1987-04-12, 1988-04-10, 1989-04-16, 1990-04-15, 1991-04-14.结合demo代码，中国在1986-05-04当天还在使用夏令时，时间被拨快了1个小时。所以0点30分打印成了1点30分。如果要打印正确的时间，可以考虑修改时区为东8区。正例：123TimeZone.setDefault(TimeZone.getTimeZone(&quot;GMT+8&quot;));SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);System.out.println(sdf.parse(&quot;1986-05-04 00:30:00&quot;));]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty（三）]]></title>
    <url>%2F2020%2F05%2F15%2Fnetty%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[无锁设计、线程绑定Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列多个工作线程模型性能更优。 Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。 高性能的序列化框架Netty默认提供了对Google Protobuf的支持，通过扩展Netty的编解码接口，用户可以实现其它的高性能序列化框架，例如Thrift的压缩二进制编解码框架。 SO_RCVBUF和SO_SNDBUF：通常建议值为128K或者256K。小包封大包，防止网络阻塞 SO_TCPNODELAY：NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。软中断Hash值和CPU绑定 软中断：开启RPS后可以实现软中断，提升网络吞吐量。RPS根据数据包的源地址，目的地址以及目的和源端口，计算出一个hash值，然后根据这个hash值来选择软中断运行的cpu，从上层来看，也就是说将每个连接和cpu绑定，并通过这个hash值，来均衡软中断在多个cpu上，提升网络并行处理性能。]]></content>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty（二）]]></title>
    <url>%2F2020%2F05%2F14%2Fnetty%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[高效的Reactor线程模型 常用的Reactor线程模型有三种，Reactor单线程模型, Reactor多线程模型, 主从Reactor多线程模型。 Reactor单线程模型 Reactor单线程模型，指的是所有的IO操作都在同一个NIO线程上面完成，NIO线程的职责如下：1) 作为NIO服务端，接收客户端的TCP连接；2) 作为NIO客户端，向服务端发起TCP连接；3) 读取通信对端的请求或者应答消息；4) 向通信对端发送消息请求或者应答消息。 由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会导致阻塞，理论上一个线程可以独立处理所有IO相关的操作。从架构层面看，一个NIO线程确实可以完成其承担的职责。例如，通过Acceptor接收客户端的TCP连接请求消息，链路建立成功之后，通过Dispatch将对应的ByteBuffer派发到指定的Handler上进行消息解码。用户Handler可以通过NIO线程将消息发送给客户端。 Reactor多线程模型 Rector多线程模型与单线程模型最大的区别就是有一组NIO线程处理IO操作。有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和N个可用的线程，由这些NIO线程负责消息的读取、解码、编码和发送； 主从 Reactor多线程模型 服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池（sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的IO操作。]]></content>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[netty（一）]]></title>
    <url>%2F2020%2F05%2F12%2Fnetty%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Netty原理 Netty是一个高性能、异步事件驱动的NIO框架，基于JAVA NIO提供的API实现。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。 Netty高性能 在IO编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。 与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。 多路复用通讯方式 Netty架构按照Reactor模式设计和实现，它的服务端通信序列图如下： 客户端通信序列图如下： Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。 异步通讯NIO 由于Netty采用了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。 零拷贝（DIRECT BUFFERS使用堆外直接内存） Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。 Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。 内存池（基于内存池的缓冲区重用机制） 随着JVM虚拟机和JIT即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区Buffer，情况却稍有不同，特别是对于堆外直接内存的分配和回收，是一件耗时的操作。为了尽量重用缓冲区，Netty提供了基于内存池的缓冲区重用机制。]]></content>
      <tags>
        <tag>java</tag>
        <tag>netty</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务（三）]]></title>
    <url>%2F2020%2F05%2F11%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[服务熔断（Hystrix） 在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。 熔断器的原理很简单，如同电力过载保护器。它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。 Hystrix 断路器机制 断路器很好理解, 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况,如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN).Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。 API 管理 SwaggerAPI管理工具：https://hacpai.com/article/1519833837647]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务（二）]]></title>
    <url>%2F2020%2F05%2F09%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[配置中心配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访问。 zookeeper配置中心实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助zookeeper的节点监听机制来实现实时感知。 配置中心数据分类 事件调度（kafka）消息服务和事件的统一调度，常用的kafka，activemq等kafka:https://juejin.im/post/5a67f7e7f265da3e3c6c4f8b 服务跟踪（starter-sleuth）随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程，Spring Cloud Sleuth正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。 为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的Trace ID。通过Trace ID的记录，我们就能将所有请求过程日志关联起来。 为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的Span ID，对于每个Span来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束Span的时间戳，就能统计出该Span的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。 在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth组件的实现。在Spring Boot应用中，通过在工程中引入 spring-cloudstarter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：①通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。②通过Zuul代理传递的请求。③通过RestTemplate发起的请求。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务（一）]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[服务注册发现 服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要Service Provider地址就行了。当下用于服务注册的工具非常多ZooKeeper，Consul，Etcd, 还有Netflix家的eureka等。服务注册有两种形式：客户端注册和第三方注册。 客户端注册（zookeeper） 客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。 第三方注册（独立的服务Registrar） 第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后Registrar负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是Registrar必须是一个高可用的系统，否则注册工作没法进展。 客户端发现 客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。 服务端发现 服务端发现需要额外的Router服务，请求先打到Router，然后Router负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证Router的高可用。 API 网关 API Gateway是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的Facade模式很像。API Gateway封装内部系统的架构，并且提供API给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的API Gateway。 API Gateway负责请求转发、合成和协议转换。所有来自客户端的请求都要先经过API Gateway，然后路由这些请求到对应的微服务。API Gateway将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在web协议与内部使用的非Web友好型协议间进行转换，如HTTP协议、WebSocket协议。 请求转发 服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上 响应合并 把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。 ps:https://blog.csdn.net/u012702547/article/details/78213270 协议转换 重点是支持SOAP，JMS，Rest间的协议转换。 ps:JSM https://www.cnblogs.com/chenpi/p/5559349.html 数据转换 重点是支持 XML和Json之间的报文格式转换能力（可选） 安全认证 基于Token的客户端访问控制和安全策略 传输数据和报文加密，到服务端解密，需要在客户端有独立的SDK代理包 基于Https的传输加密，客户端和服务端数字证书支持 基于OAuth2.0的服务安全认证(授权码，客户端，密码模式等）]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring原理（五）]]></title>
    <url>%2F2020%2F05%2F01%2Fspring%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JPA原理事务 事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation )和持久性(Durabilily)。 本地事务 紧密依赖于底层资源管理器（例如数据库连接 )，事务处理局限在当前事务资源内。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下：1234567891011121314151617181920212223public void transferAccount() &#123; Connection conn = null; Statement stmt = null; try &#123; conn = getDataSource().getConnection(); // 将自动ᨀ交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动ᨀ交 conn.setAutoCommit(false); stmt = conn.createStatement(); // 将 A 账户中的金额减少 500 stmt.execute(&quot;update t_account set amount = amount - 500 where account_id = &apos;A&apos;&quot;); // 将 B 账户中的金额增加 500 stmt.execute(&quot;update t_account set amount = amount + 500 where account_id = &apos;B&apos;&quot;); // ᨀ交事务 conn.commit(); // 事务ᨀ交：转账的两步操作同时成功 &#125; catch (SQLException sqle) &#123; // 发生异常，回滚在本事务中的操做 conn.rollback(); // 事务回滚：转账的两步操作完全撤销 stmt.close(); conn.close(); &#125;&#125; 分布式事务 Java事务编程接口（JTA：Java Transaction API）和Java事务服务(JTS；Java Transaction Service)为J2EE平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器(Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。12345678910111213141516171819202122232425public void transferAccount2() &#123; UserTransaction userTx = null; Connection connA = null; Statement stmtA = null; Connection connB = null; Statement stmtB = null; try &#123; // 获得 Transaction 管理对象 userTx = (UserTransaction)getContext().lookup(&quot;java:comp/UserTransaction&quot;); connA = getDataSourceA().getConnection();// 从数据库 A 中取得数据库连接 connB = getDataSourceB().getConnection();// 从数据库 B 中取得数据库连接 userTx.begin(); // 启动事务 stmtA = connA.createStatement();// 将 A 账户中的金额减少 500 stmtA.execute(&quot;update t_account set amount = amount - 500 where account_id = &apos;A&apos;&quot;); // 将 B 账户中的金额增加 500 stmtB = connB.createStatement(); stmtB.execute(&quot;update t_account set amount = amount + 500 where account_id = &apos;B&apos;&quot;); userTx.commit();// 提交事务 // 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新） &#125; catch (SQLException sqle) &#123; // 发生异常，回滚在本事务中的操纵 userTx.rollback();// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销 &#125; catch (Exception ne) &#123; &#125;&#125; 两阶段提交 两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：第一阶段：准备阶段；第二阶段：提交阶段。 准备阶段 事务协调者(事务管理器)给每个参与者(资源管理器)发送Prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种“万事俱备，只欠东风”的状态。 提交阶段 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) 将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot(一)]]></title>
    <url>%2F2020%2F04%2F30%2FSpringboot-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。其特点如下： 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成和对XML没有要求配置 [1] 约定大于配置是springboot的主导思想，对于springboot而言，大部分情况下存在默认的配置。 对于你收这些项目必须的功能，Springboot 提供starter的依赖，例如spring-boot-starter-web提供了SpringMVC所依赖的包，spring-boot-starter-tomcat绑定了内嵌的tomcat,这样能使开发者尽快的搭建环境，快速开发和部署]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring原理（四）--MVC流程和注解]]></title>
    <url>%2F2020%2F04%2F28%2FSpring%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。 MVC流程 Http请求到DispatcherServlet(1)客户端请求提交到DispatcherServlet。 HandlerMapping寻找处理器(2)由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。 调用处理器Controller(3)DispatcherServlet将请求提交到Controller。Controller调用业务逻辑处理后，返回ModelAndView。 (4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。DispatcherServlet查询ModelAndView (6)(7)处理视图映射并返回模型：DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。ModelAndView反馈浏览器HTTP (8)Http响应：视图负责将结果显示到客户端。 MVC 常用注解【类上的标注】@Controller 用于标注控制层组件，标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象，分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解，可以吧Request请求header部分的值绑定到方法的参数上。@RestController 相当于@Controller和@reponseBody的组合效果@Conmponent 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注@Repository 用于注解dao层，在daoImpl类上面注解@Service 用于标注业务层组件【类内的标注】@ResponseBody 异步请求，用于将Controller的方法返回的对象，通过适当单独HTTPMessageConverter转换为指定格式后，写入到Response对象的body数据区。返回的数据不是html标签的页面，而是其他某种格式的数据（json,xml）时使用@RequestMapping 一个用来处理请求地址映射的注解，可用于类或者方法上，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。@Autowired 他对类成员变量，方法及构造函数进行标注，完成自动装配的工作，通过@Autowired的使用来消除setget方法。@PathVariable 用于将请求url中的模板变量映射到功能处理方法的参数上，即取出url模板中的变量作为参数@RequestParam 主要用于在SpringMVC后台控制层获取参数，类似一种request.getParameter(“name”)@RequestHeader 可以把request请求header部分父值绑定到方法的参数上。]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring原理（三）---AOP]]></title>
    <url>%2F2020%2F04%2F27%2FSpring%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概念 “横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 AOP主要应用场景有: Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 AOP核心概念 切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象。 横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。 连接点（joinpoint）：被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。 切入点（pointcut）：对连接点进行拦截的定义 通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。 目标对象：代理的目标对象 织入（weave）：将切面应用到目标对象并导致代理对象创建的过程 引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。 AOP两种代理方式 Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。 JDK动态接口代理 JDK动态代理主要涉及到java.lang.reflect包中的两个类：Proxy和InvocationHandler。InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy利用InvocationHandler动态创建一个符合某一接口的实例，生成目标类的代理对象。 CGLib动态代理 CGLib全称为Code Generation Library，是一个强大的高性能，高质量的代码生成类库，可以在运行期扩展Java类与实现Java接口，CGLib封装了asm，可以再运行期动态生成新的class。 和JDK动态代理相比较：JDK创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过CGLib创建动态代理。 实现原理12345678910111213141516171819@Aspectpublic class TransactionDemo &#123; @Pointcut(value = &quot;execution(* com.wuxu.core.service.*.*.*(..))&quot;) public void point() &#123;&#125; @Before(value = &quot;point()&quot;) public void before() &#123; System.out.println(&quot;transaction begin&quot;); &#125; @AfterReturning(value = &quot;point()&quot;) public void after() &#123; System.out.println(&quot;transaction commit&quot;); &#125; @Around(&quot;point()&quot;) public void around(ProceedingJoinPoint joinPoint) throws Throwable &#123; System.out.println(&quot;transaction begin&quot;); joinPoint.proceed(); System.out.println(&quot;transaction commit&quot;); &#125;&#125; 参考https://blog.csdn.net/moreevan/article/details/11977115/#]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring原理（二）--IOC 原理]]></title>
    <url>%2F2020%2F04%2F26%2FSpring%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概念 Spring通过一个配置文件描述Bean及Bean之间的依赖关系，利用Java语言的反射功能实例化Bean并建立Bean之间的依赖关系。Spring的IoC容器在完成这些底层工作的基础上，还提供了Bean实例缓存、生命周期管理、Bean实例代理、事件发布、资源装载等高级服务。 Spring容器高层视图 Spring启动时读取应用程序提供的Bean配置信息，并在Spring容器中生成一份相应的Bean配置注册表，然后根据这张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境。其中Bean缓存池为HashMap实现。 IOC容器实现BeanFactory-框架基础设施 BeanFactory是Spring框架的基础设施，面向Spring本身；ApplicationContext面向使用Spring框架的开发者，几乎所有的应用场合我们都直接使用ApplicationContext而非底层的BeanFactory。 BeanDefinitionRegistry注册表 Spring配置文件中每一个节点元素在Spring容器里都通过一个BeanDefinition对象表示，它描述了Bean的配置信息。而BeanDefinitionRegistry接口提供了向容器手工注册BeanDefinition对象的方法。 BeanFactory顶层接口 位于类结构树的顶端，它最主要的方法就是getBean(String beanName)，该方法从容器中返回特定名称的Bean，BeanFactory的功能通过其他的接口得到不断扩展。 ListableBeanFactory 该接口定义了访问容器中Bean基本信息的若干方法，如查看Bean的个数、获取某一类型Bean的配置名、查看容器中是否包括某一Bean等方法。 HierarchicalBeanFactory父子级联 父子级联IoC容器的接口，子容器可以通过接口方法访问父容器；通过HierarchicalBeanFactory接口，Spring的IoC容器可以建立父子层级关联的容器体系，子容器可以访问父容器中的Bean，但父容器不能访问子容器的Bean。Spring使用父子容器实现了很多功能，比如在SpringMVC中，展现层Bean位于一个子容器中，而业务层和持久层的Bean位于父容器中。这样，展现层Bean就可以引用业务层和持久层的Bean，而业务层和持久层的Bean则看不到展现层的Bean。 ConfigurableBeanFactory ConfigurableBeanFactory是一个重要的接口，增强了IoC容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法； AutowireCapableBeanFactory自动装配 定义了将容器中的Bean按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法。 SingletonBeanRegistry运行期间注册单例Bean 定义了允许在运行期间向容器注册单实例Bean的方法；对于单实例（singleton）的Bean来说，BeanFactory会缓存Bean实例，所以第二次使用getBean()获取Bean时将直接从IoC容器的缓存中获取Bean实例。Spring在DefaultSingletonBeanRegistry类中提供了一个用于缓存单实例Bean的缓存器，它是一个用HashMap实现的缓存器，单实例的Bean以beanName为键保存在这个HashMap中。 依赖日志框框 在初始化BeanFactory时，必须为其提供一种日志框架，比如使用Log4J，即在类路径下提供Log4J配置文件，这样启动Spring容器才不会报错。 ApplicationContext面向开发应用 ApplicationContext由BeanFactory派生而来，提供了更多面向实际应用的功能。ApplicationContext继承了HierarchicalBeanFactory和ListableBeanFactory接口，在此基础上，还通过多个其他的接口扩展了BeanFactory的功能。 ClassPathXmlApplicationContext：默认从类路径加载配置文件 FileSystemXmlApplicationContext：默认从文件系统中装载配置文件 ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。 MessageSource：为应用提供i18n国际化消息访问的功能； ResourcePatternResolver：所有ApplicationContext实现类都实现了类似于PathMatchingResourcePatternResolver的功能，可以通过带前缀的Ant风格的资源文件路径装载Spring的配置文件。 LifeCycle：该接口是Spring2.0加入的，该接口提供了start()和stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext实现及具体Bean实现，ApplicationContext会将start/stop的信息传递给容器中所有实现了该接口的Bean，以达到管理和控制JMX、任务调度等目的。 ConfigurableApplicationContext扩展于ApplicationContext，它新增加了两个主要的方法：refresh()和close()，让ApplicationContext具有启动、刷新和关闭应用上下文的能力。在应用上下文关闭的情况下调用refresh()即可启动应用上下文，在已经启动的状态下，调用refresh()则清除缓存并重新装载配置信息，而调用close()则可关闭应用上下文。 WebApplication体系架构 WebApplicationContext是专门为Web应用准备的，它允许从相对于Web根目录的路径中装载配置文件完成初始化工作。从WebApplicationContext中可以获得ServletContext的引用，整个Web应用上下文对象将作为属性放置到ServletContext中，以便Web应用环境可以访问Spring应用上下文。 SpringBean作用域 Spring中为Bean定义了5种作用域，分别为singleton（单例）、prototype（原型）、request、session和global session。 singleton：单例模式（多线程下不安全） singleton：单例模式，Spring IoC容器中只会存在一个共享的Bean实例，无论有多少个Bean引用它，始终指向同一对象。该模式在多线程下是不安全的。Singleton作用域是Spring中的缺省作用域，也可以显示的将Bean定义为singleton模式，配置为：1&lt;bean id=&quot;userDao&quot; class=&quot;com.ioc.UserDaoImpl&quot; scope=&quot;singleton&quot;/&gt; prototype:原型模式每次使用时创建 prototype:原型模式，每次通过Spring容器获取prototype 定义的bean时，容器都将创建一个新的Bean实例，每个Bean实例都有自己的属性和状态，而singleton全局只有一个对象。根据经验，对有状态的bean使用prototype作用域，而对无状态的bean使用singleton作用域。 Request：一次request一个实例 request：在一次 Http 请求中，容器会返回该Bean的同一实例。而对不同的Http请求则会产生新的Bean，而且该bean仅在当前Http Request内有效,当前Http 请求结束，该bean实例也将会被销毁。1&lt;bean id=&quot;loginAction&quot; class=&quot;com.cnblogs.Login&quot; scope=&quot;request&quot;/&gt; session session：在一次Http Session中，容器会返回该Bean的同一实例。而对不同的Session请求则会创建新的实例，该bean实例仅在当前Session内有效。同Http请求相同，每一次session请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的session请求内有效，请求结束，则实例将被销毁。 global Session global Session：在一个全局的Http Session中，容器会返回该Bean的同一个实例，仅在使用portlet context时有效。 Spring Bean生命周期 实例化一个Bean，也就是我们常说的new。 按照Spring上下文对实例化的Bean进行配置，也就是IOC注入。 如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，此处传递的就是Spring 配置文件中Bean的id值。 如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现的setBeanFactory，setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean，只需在Spring配置文件中配置一个普通的Bean就可以）。 如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，传入Spring上下文（同样这个方式也可以实现步骤4的内容，但比4更好，因为ApplicationContext是BeanFactory的子接口，有更多的实现方法） 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，BeanPostProcessor经常被用作是Bean内容的更改，并且由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。 如果这个Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。注：以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Sprin 配置文件中也可以配置非Singleton。 当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用那个其实现的destroy()方法； 最后，如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法。 bean标签有两个重要的属性（init-method 和destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct和@PreDestroy）。1&lt;bean id=&quot;&quot; class=&quot;&quot; init-method=&quot;初始化方法&quot; destroy-method=&quot;销毁方法&quot;&gt; Spring依赖注入四种方式 构造器注入 1234567/*带参数，方便利用构造器进行注入*/public CatDaoImpl(String message)&#123; this. message = message;&#125; &lt;bean id=&quot;CatDaoImpl&quot; class=&quot;com.CatDaoImpl&quot;&gt; &lt;constructor-arg value=&quot; message &quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; setter方法注入 123456public class Id &#123; private int id; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125;&#125;&lt;bean id=&quot;id&quot; class=&quot;com.id &quot;&gt; &lt;property name=&quot;id&quot; value=&quot;123&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 静态工厂注入 静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让spring管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过spring注入的形式获取。 12345678910111213141516171819public class DaoFactory &#123; //静态工厂 public static final FactoryDao getStaticFactoryDaoImpl()&#123; return new StaticFacotryDaoImpl(); &#125;&#125;public class SpringAction &#123; private FactoryDao staticFactoryDao; //注入对象 //注入对象的 set 方法 public void setStaticFactoryDao(FactoryDao staticFactoryDao) &#123; this.staticFactoryDao = staticFactoryDao; &#125;&#125;//factory-method=&quot;getStaticFactoryDaoImpl&quot;指定调用哪个工厂方法&lt;bean name=&quot;springAction&quot; class=&quot; SpringAction&quot; &gt; &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt; &lt;property name=&quot;staticFactoryDao&quot; ref=&quot;staticFactoryDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;&lt;bean name=&quot;staticFactoryDao&quot; class=&quot;DaoFactory&quot; factory-method=&quot;getStaticFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 实例工厂 实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先new工厂类，再调用普通的实例方法。 123456789101112131415161718public class DaoFactory &#123; //实例工厂 public FactoryDao getFactoryDaoImpl()&#123; return new FactoryDaoImpl(); &#125;&#125;public class SpringAction &#123; private FactoryDao factoryDao; //注入对象 public void setFactoryDao(FactoryDao factoryDao) &#123; this.factoryDao = factoryDao; &#125;&#125;&lt;bean name=&quot;springAction&quot; class=&quot;SpringAction&quot;&gt; &lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt; &lt;property name=&quot;factoryDao&quot; ref=&quot;factoryDao&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;&lt;bean name=&quot;daoFactory&quot; class=&quot;com.DaoFactory&quot;&gt;&lt;/bean&gt;&lt;bean name=&quot;factoryDao&quot; factory-bean=&quot;daoFactory&quot; factory-method=&quot;getFactoryDaoImpl&quot;&gt;&lt;/bean&gt; 5种不同方式的自动装配 Spring装配包括手动装配和自动装配，手动装配是有基于xml装配、构造方法、setter方法等自动装配有五种自动装配的方式，可以用来指导Spring容器用自动装配方式来进行依赖注入。 no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。 byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。 byType：通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。 constructor：这个方式类似于byType，但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 autodetect：首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring原理（一）]]></title>
    <url>%2F2020%2F04%2F21%2Fspring%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[spring是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。而且Spring仍然可以和其他的框架无缝整合。 Spring特点 轻量级从大小和开销两个方面而言spring都是轻量级的，完整的spring框架可以在一个大小只有1M多的jar文件中发布，并且spring所需的处理开销也是微不足道的。 控制反转spring通过一种乘坐控制反转IOC的技术促进了低耦合。当应用了IOC,一个对象依赖的其他对象会通过被动的方式传递进来，而不是这对象资金创建或者查找一栏对象。 面向切面spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 容器spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建—基于一个可配置的原型，你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例–以及它们是如何互相关联的。 框架集合spring可以将简单的组件配置，组合成复杂的应用。在spring中，应用对象被声明式的组合，典型的是在一个xml文件中。spring也提供了很多基础功能（事务管理，持久化框架集成等），将应用逻辑的开发留给开发者。 方便解耦，简化开发 声明式事务的支持 降低Java EE API的使用难度 Spring核心组件 Spring常用模块 核心容器核心容器提供spring框架的基本功能，核心容器的主要组件是BeanFactory,他是工厂模式的实现，BeanFactory使用控制反转模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。 Spring上下文Spring上下文是一个配置文件，向Spring框架提供上下文信息，Spring上下文包括企业服务，例如：JNDI,EJB,电子邮件，国际化，校验和调度功能。 Spring AOP通过配置管理特性，SpringAOP模块直接向面向切面的编程功能集成到了Spring框架中，可以将一些通用任务，如安全，事物，日志，等集中进行管理，提高了复用性和管理的便捷性。 Spring DAO为JDBC DAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息，异常层次结构简化了错误处理，并且极大的降低了需要便携的异常代码数量，SpringDAO的面向JDBC的异常存从通用的DAO异常层次结构。 Spring ORMspring框架插入了若干和ORM框架，从而提供了ORM的对象关系工具，其中包括JDO，Hibernate,IBatista SQL Map。所有这些都遵从了Spring的通用实物和DAO的异常曾子结构。 Sping Web 模块Web上下文模块创建在应用程序上下文模块之上，为基于Web的应用程序创建了提供上下文，所以Srping框架支持Jakarta Struts的集成，Web模块还减缓了处理多部分请求以及将请求参数绑定到域对象的工作。 Spring MVC框架MVC框架是衣蛾全功能的构建Web应用程序的MVC实现，通过策略接口，MVC框架编程了高度可配置的，MVC容纳了大量的视图技术，其中包括JSP，Velocity,Ties，iTest和POI。 Spring主要包core—-Spring核心工具包，其他包依赖此包beans—-所有应用都用到，包含访问配置文件，创建和管理bean等。aop—-Spring的面向切面编程，提供AOP（面向切面编程）的实现context—-提供在基础IOC功能上的扩展服务，此外还提供许多企业级服务的支持，有邮件服务、任务调度。JNDI定位，EJB集成，远程访问，缓存以及多种视图层框架的支持。web.mvc—-包含SpringMVC应用开发时所需的核心类。transaction—-为JDBC,Hibernate，JDO,JPA提供一致的声明式和编程式事务管理web—–包含Web应用开发时，用到Spring关键时所需的核心类。aspects—-Spring提供的对AspectJ框架的整合test—-对JUNIT等测试框架的简单封装asm—-spring3.0开始提供自己独立的asm jar包context.support—-spring context的扩展支持，用于MVC方面expression—-Spring表达式语言instrument.tomcat—-Spring对tomcat连接池的集成instrument—-Spring对服务器的代理接口jdbc—-为JDBC的简单封装jms—-为简化jms api的使用而做的简单封装orm—-整合第三方的orm实现，如hibernate,ibatis,jdo,jpa等oxm—-Spring对于object/xml映射的支持，可以让java与xml来回切换web.portlet—-Spring MVC的增强web.servlet—-对J2EE6.0 servlet3.0的支持web.struts—-整合对struts框架的支持，更方便更容易的集成Struts框架。 Spring 常用注解bean注入与装配的的方式有很多种，可以通过xml，get set方式，构造函数或者注解等。简单易用的方式就是使用Spring的注解了，Spring提供了大量的注解方式。【1】@Controller 用于标注控制层组件，用于标记在一个类上，使用它标记的类就是一个SpringMVC Controller对象，分发处理器将会扫描使用了该注解的类的方法，并检测该方法是否使用了@RequestMapping注解，可以把Request请求header部分的值绑定到方法的参数上@RestController相当于@Controller和ResponseBody的组合效果@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。@Respository用于注解dao，在daoimpl类上注解。@Service用于标注业务层组件【2】@ResponseBody异步请求，该注解用于将Controller的方法返回的对象。通过适当的HttpMessageConverter转换为指定格式后，写入Response对象的body数据区。返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml）使用@RequestMapping一个用来处理请求地址映射的注解，可用于类或方法上，用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径@Aurowired可以对类成员变量、方法及构造函数进行标注、完成自动装配的工作，通过@Autowired的使用来消除setget方法@PathValiable用于将请求URL中的模板变量映射到功能处理方法的参数上，即去除url模板中的变量作为参数@RequestParam主要用于在SpringMVC后台控制层获取参数，类似一种是request.getParameter(“name”)@RequestHeader而言吧Request请求header部分的值绑定到方法的参数上【3】@ModelAttribute该Controller的所有方法在调用前，先执行此@ModelAttribute方法，可用于注解和方法参数中，可以把这个@ModelAttribute特征，应用在BaseController当中，所有Controller继承BaseController,即可实现在调用Controller时，先执行@ModelAttibute方法。@SessionAttributes即将值放在session作用域中，卸载class上面。@Valid实体数据校验，可以结合hibernate validator以前使用@CookieValue用来获取Cookie中的值 装配注解比较【包区别】@Resource javax.annotation java@Inject javax.inject java@Qualifier javax.inject java@Autowired org.springframework.bean.factory java【@Autowored和@Inject】二者基本相同，但@Autowird不能离开spring环境1.按照类型匹配 2.按照限定符进行类型限定 3.按照名称匹配【@Resource】1.按照名称匹配，2.按照类型匹配 3.按照限定符进行类型限定（但如果名称匹配成功的话这条会被忽略） Spring 第三方结合【权限】shiro,java的一个安全框架，认证，授权，加密，会话管理，与Web集成，缓存以及多种视图层框架的支持。【缓存】redis：一个开源的使用ANSI C语言填写，支持网络，可基于内存亦可持久化的日志型，Key-value数据库【持久化框架】Mybatis:是支持普通Sql查询，存储过程和高级映射的优秀持久层框架【定时任务】quartz:一个开源的作业调度框架，由java编写，在.NET平台为Quartz.net通过Quart可以快速的完成任务调度的工作。Spring-Task:轻量型的Quartz，而且使用起来简单，除spring相关的包外不需要额外的包，而且支持注解和配置文件两种形式。【校验框架】Oval：oval是一个可扩展的的java对象数据验证框架，验证的规则可以通过配置文件，Annotation,POJOs进行设定，可以使用纯java语言，javaScript,Groovy，BeanShell等进行规则的编写。]]></content>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（五）]]></title>
    <url>%2F2020%2F04%2F20%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java序列化保存(持久化)对象及其状态到内存或者磁盘 Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。 序列化对象以字节数组保持-静态成员不保存 使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。 序列化用户远程对象传输 除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。 Serializable 实现序列化 在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。 通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化。 在类中增加writeObject和readObject方法可以实现自定义序列化策略。 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化ID是否一致（就是private static final long serialVersionUID） 序列化并不保存静态变量 要想将父类对象也序列化，就需要让父类也实现Serializable接口 Transient关键字 Transient关键字阻止该变量被序列化到文件中 在变量声明前加上Transient关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient变量的值被设为初始值，如int型的是0，对象型的是null。 服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 JAVA复制 将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。这三种概念实际上都是为了拷贝对象。 直接赋值复制 在Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说a1和a2指向的是同一个对象。因此，当a1变化的时候，a2里面的成员变量也会跟着变化。 浅复制（复制引用但不复制引用的对象） 创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。 深复制（复制对象和其应用对象） 深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。 序列化（深clone一中实现） 在Java语言里深复制一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（四）]]></title>
    <url>%2F2020%2F04%2F20%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA内部类 Java类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。 静态内部类 定义在类内部的静态类，就是静态内部类。 静态内部类可以访问外部类所有的静态变量和方法，即使是private的也一样。 静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。 其它类使用静态内部类需要使用”外部类.静态内部类”方式，如下所示：Out.Inner inner =new Out.Inner();inner.print(); Java集合类HashMap内部就有一个静态内部类Entry。Entry是HashMap存放元素的抽象，HashMap内部维护Entry数组用了存放元素，但是Entry对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。 成员内部类 定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final修饰的除外）。这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。 局部内部类（定义在方法中的类） 定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。 匿名内部类（要继承一个父类或者实现一个接口，直接使用new来生成一个对象的引用） 匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。 JAVA泛型 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。 比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用Java泛型。 泛型方法（） 可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。121. &lt;? extends T&gt;表示该通配符所代表的类型是T类型的子类。2. &lt;? super T&gt;表示该通配符所代表的类型是T类型的父类。 泛型类 泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 出于规范的目的，Java还是建议用单个大写字母来代表类型参数。常见的如：T 代表一般的任何类。E 代表Element的意思，或者Exception异常的意思。K 代表Key的意思。V 代表Value的意思，通常与K一起配合使用。S 代表Subtype的意思。 类型通配符? 通配符的出现是为了指定泛型中的类型范围。 通配符有3种形式:&lt;?&gt;被称作无限定的通配符。&lt;? extends T&gt;被称作有上限的通配符。&lt;? super T&gt;被称作有下限的通配符。 无限定的通配符 无限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。 例如 List&lt;?&gt; 在逻辑上是List,List 等所有 List&lt;具体类型实参&gt;的父类。 类型擦除 Java中的泛型基本上都是在编译器这个层次来实现的。在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的List和 List等类型，在编译之后都会变成 List。JVM看到的只是List，而由泛型附加的类型信息对JVM来说是不可见的。类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。 类型擦除带来的局限性 类型擦除，是泛型能够与之前的java版本代码兼容共存的原因。但也因为类型擦除，它会抹掉很多继承相关的特性，这是它带来的局限性。 泛型类或者泛型方法中，不接受8种基本数据类型。 Java不能创建具体类型的泛型数组。 但是利用类型擦除的原理，用反射的手段就绕过了正常开发中编译器不允许的操作限制。 泛型好处 泛型抽离了数据类型与代码逻辑，本意是提高程序代码的简洁性和可读性，并提供可能的编译时类型转换安全检测功能。 而类型擦除，使泛型能够与之前的java版本代码兼容共存。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（三）]]></title>
    <url>%2F2020%2F04%2F19%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA注解 Annotation（注解）是Java提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。Annatation(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 Annotation对象，然后通过该Annotation对象来获取注解中的元数据信息。 4种标准元注解 元注解的作用是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它annotation类型作说明。@Target 修饰的对象范围 @Target说明了Annotation所修饰的对象范围：Annotation可被用于packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在Annotation类型的声明中使用了target 可更加明晰其修饰的目标。@Retention 定义 被保留的时间长短 Retention定义了该Annotation被保留的时间长短：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由： SOURCE:在源文件中有效（即源文件保留） CLASS:在 class 文件中有效（即 class 保留） RUNTIME:在运行时有效（即运行时保留） @Documented描述-javadoc @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。@Inherited 阐述了某个被标注的类型是被继承的 @Inherited元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注解处理器 如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /*1：*** 定义注解*/@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface FruitProvider &#123; /** 供应商编号 */ public int id() default -1; /*** 供应商名称 */ public String name() default &quot;&quot;; /** * 供应商地址 */ public String address() default &quot;&quot;;&#125; /*2：注解使用*/public class Apple &#123; @FruitProvider(id = 1, name = &quot;陕西红富士集团&quot;, address = &quot;陕西省西安市延安路&quot;) private String appleProvider; public void setAppleProvider(String appleProvider) &#123; this.appleProvider = appleProvider; &#125; public String getAppleProvider() &#123; return appleProvider; &#125;&#125;/*3：*********** 注解处理器 ***************/public class FruitInfoUtil &#123; public static void getFruitInfo(Class&lt;?&gt; clazz) &#123; String strFruitProvicer = &quot;供应商信息：&quot;; Field[] fields = clazz.getDeclaredFields();// 通过反射获取处理注解 for (Field field : fields) &#123; if (field.isAnnotationPresent(FruitProvider.class)) &#123; FruitProvider fruitProvider = (FruitProvider)field.getAnnotation(FruitProvider.class); // 注解信息的处理地方 strFruitProvicer = &quot; 供应商编号：&quot; + fruitProvider.id() + &quot; 供应商名称：&quot; + fruitProvider.name() + &quot; 供应商地址：&quot; + fruitProvider.address(); System.out.println(strFruitProvicer); &#125; &#125; &#125;&#125;/*4：*********** 应用 ***************/public class FruitRun &#123; public static void main(String[] args) &#123; FruitInfoUtil.getFruitInfo(Apple.class); /*********** 输出结果 ***************/ // 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延 &#125;&#125; Java 8中注解新特性 @Repeatable 元注解,表示被修饰的注解可以用在同一个声明式或者类型加上多个相同的注解（包含不同的属性值） @Native 元注解,本地方法 java8中Annotation可以被用在任何使用Type的地方 进阶https://www.jianshu.com/p/89c07ce0c99c]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密算法--AES]]></title>
    <url>%2F2020%2F04%2F17%2F%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95-AES%2F</url>
    <content type="text"><![CDATA[java实现AES加密算法，随机iv值合入到加密文件中，使得每次加密的内容不一样。核心代码如下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public static final int AES_KEY_SIZE = 256; // in bitspublic static final int GCM_NONCE_LENGTH = 12; // in bytespublic static final String CIPHER = &quot;AES&quot;;public static final String AES_GCM_NOPADDING = &quot;AES/GCM/NoPadding&quot;;// java 8-u162 以后版本才支持public static final String AES_GCM_PKCS5PADDING = &quot;AES/GCM/PKCS5Padding&quot;;// java 8-u162 以后版本才支持public static final String AES_CBC_NOPADDING = &quot;AES/CBC/NoPadding&quot;;public static final String AES_CBC_PKCS5PADDING = &quot;AES/CBC/PKCS5Padding&quot;; /** * 生成秘钥的方法 * * @param encryptPass * @return */public static SecretKey getSecreKey(String encryptPass) &#123; SecretKey key = null; try &#123; KeyGenerator keyGen = KeyGenerator.getInstance(CIPHER); keyGen.init(AES_KEY_SIZE, new SecureRandom(encryptPass.getBytes(StandardCharsets.UTF_8))); key = keyGen.generateKey(); System.out.println(Base64.getEncoder().encodeToString(key.getEncoded())); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; return key;&#125;/** * AES加密 * * @param content * @param encryptPass * @return */public static String encrypt(String content, String encryptPass) &#123; try &#123; Cipher cipher = Cipher.getInstance(AES_GCM_PKCS5PADDING); cipher.init(Cipher.ENCRYPT_MODE, getSecreKey(encryptPass)); byte[] iv = cipher.getIV(); byte[] encryptData = cipher.doFinal(content.getBytes(StandardCharsets.UTF_8)); byte[] message = new byte[12 + content.getBytes(StandardCharsets.UTF_8).length + 16]; System.arraycopy(iv, 0, message, 0, 12); System.arraycopy(encryptData, 0, message, 12, encryptData.length); return Base64.getEncoder().encodeToString(message); &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException e) &#123; e.printStackTrace(); &#125; return null;&#125;/** * AES解密 * * @param base64Content * @param encryptPass * @return * @throws IllegalBlockSizeException */public static String decrypt(String base64Content, String encryptPass) throws IllegalBlockSizeException &#123; byte[] content = Base64.getDecoder().decode(base64Content); if (content.length &lt; 12 + 16) &#123; throw new IllegalBlockSizeException(); &#125; GCMParameterSpec spec = new GCMParameterSpec(GCM_TAG_LENGTH * 8, content, 0, 12); try &#123; Cipher cipher = Cipher.getInstance(AES_GCM_PKCS5PADDING); cipher.init(Cipher.DECRYPT_MODE, getSecreKey(encryptPass), spec); byte[] decryptData = cipher.doFinal(content, 12, content.length - 12); return new String(decryptData); &#125; catch (NoSuchAlgorithmException | NoSuchPaddingException | IllegalBlockSizeException | BadPaddingException | InvalidKeyException | InvalidAlgorithmParameterException e) &#123; e.printStackTrace(); &#125; return null;&#125; 注意：GCM模式java 8-u162 版本以后才支持，以前的版本不能使用该加密模式。不建议使用ECB模式，ECB模式现阶段存在破解的可能。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（二）]]></title>
    <url>%2F2020%2F04%2F15%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA反射先了解一下动态语言，动态语言是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的JavaScript就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而C、C++则不属于动态语言。从反射角度说JAVA属于半动态语言。 反射机制概念（运行状态中知道类所有的属性和方法）在Java中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为Java语言的反射机制。 反射的应用场合编译时类型和运行时类型 在Java程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定。如：Person p=new Student();其中编译时类型为Person，运行时类型为Student。 编译时类型无法获取具体方法 程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为Object,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。 Java反射API 反射API用来生成JVM中的类、接口或则对象的信息 Class类：反射的核心类，可以获取类的属性，方法等信息。 Field类：Java.lang.reflec包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。 Method类：Java.lang.reflec包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。 Constructor类：Java.lang.reflec包中的类，表示类的构造方法。 反射使用步骤（获取 Class 对象、调用对象方法） 获取想要操作的类的Class对象，他是反射的核心，通过Class对象我们可以任意调用类的方法。 调用Class类中的方法，既就是反射的使用阶段。 使用反射API来操作这些信息。 获取Class对象的3种方法 调用某个对象的 getClass()方法 Person p=new Person();Class clazz=p.getClass(); 调用某个类的class属性来获取该类对应的Class对象。Class clazz=Person.class; 使用Class类中的forName()静态方法(最安全/性能最好)Class clazz=Class.forName(“类的全路径”); (最常用) 创建对象的两种方法 Class对象的newInstance()。使用Class对象的newInstance()方法来创建该Class对象对应类的实例，但是这种方法要求该Class对象对应的类有默认的空构造器。 调用Constructor（构造器）对象的newInstance()先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建Class对象对应类的实例,通过这种方法可以选定构造方法创建实例。12345678//获取 Person 类的 Class 对象Class clazz=Class.forName(&quot;reflection.Person&quot;);//使用newInstane() 方法创建对象Person p=(Person) clazz.newInstance();//获取构造方法(Constructor)并创建对象Constructor c=clazz.getDeclaredConstructor(String.class,String.class,int.class);//创建对象并设置属性Person p1=(Person) c.newInstance(&quot;李四&quot;,&quot;男&quot;,20);]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础（一）]]></title>
    <url>%2F2020%2F04%2F15%2Fjava%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA异常分类及处理 如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。 异常分类 Throwable是Java语言中所有错误或异常的超类。下一层分为Error和Exception。 Error Error类是指java运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。 Exception（RuntimeException、CheckedException） Exception又有两个分支，一个是运行时异常RuntimeException，一个是CheckedException。 RuntimeException 比如NullPointerException、ClassCastException。如果出现RuntimeException，那么一定是程序员的错误。 检查异常 CheckedException 比如I/O错误导致的IOException、SQLException。RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常的超类。 一般是外部错误，这种异常都发生在编译阶段，Java编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行try catch，该类异常一般包括几个方面： 试图在文件尾部读取数据 试图打开一个错误格式的URL 试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在 异常的处理方式 遇到问题不进行具体处理，而是继续抛给调用者（throw,throws）,抛出异常有三种形式，一是throw,一个throws，还有一种系统自动抛异常。 try catch捕获异常针对性处理方式 Throw和throws的区别： throws用在函数上，后面跟的是异常类，可以跟多个；而throw用在函数内，后面跟的是异常对象。 throws用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并将具体的问题对象抛给调用者。也就是说throw语句独立存在时，下面不要定义其他语句，因为执行不到。 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常对象。 两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（十二）]]></title>
    <url>%2F2020%2F04%2F13%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[AQS（抽象的队列同步器） AbstractQueuedSynchronizer类如其名，抽象的队列式的同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch。 它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。 state的访问方式有三种:getState(),setState(),compareAndSetState()。 AQS 定义两种资源共享方式 Exclusive独占资源-ReentrantLockExclusive（独占，只有一个线程能执行，如ReentrantLock） Share共享资源-Semaphore/CountDownLatchShare（共享，多个线程可同时执行，如Semaphore/CountDownLatch）。 AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的 get/set/CAS)之所以没有定义成abstract ，是因为独占模式下只用实现tryAcquire-tryRelease ，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。 自定义同步器实现时主要实现以下几种方法： isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。 tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。 tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。 tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。 同步器的实现是 ABS 核心（state 资源状态计数） 同步器的实现是ABS核心，以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。 以CountDownLatch以例，任务分为N个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS减 1。等到所有子线程都执行完后(即 state=0)，会 unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。 ReentrantReadWriteLock实现独占和共享两种方式 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquiretryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（十一）]]></title>
    <url>%2F2020%2F04%2F12%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java CAS 原理剖析 在Java并发中，我们最初接触的应该就是synchronized关键字了，但是synchronized属于重量级锁，很多时候会引起性能问题，volatile也是个不错的选择，但是volatile不能保证原子性，只能在某些场合下使用。 像synchronized这种独占锁属于悲观锁，它是在假设一定会发生冲突的，那么加锁恰好有用，除此之外，还有乐观锁，乐观锁的含义就是假设没有发生冲突，那么我正好可以进行某项操作，如果要是发生冲突呢，那我就重试直到成功，乐观锁最常见的就是CAS。 我们在读Concurrent包下的类的源码时，发现无论是ReenterLock内部的AQS，还是各种Atomic开头的原子类，内部都应用到了CAS，最常见的就是我们在并发编程时遇到的i++这种情况。传统的方法肯定是在方法上加上synchronized关键字:123456public class Test &#123; public volatile int i; public synchronized void add() &#123; i++; &#125;&#125; 但是这种方法在性能上可能会差一点，我们还可以使用AtomicInteger，就可以保证i原子的++了。123456public class Test &#123; public AtomicInteger i; public void add() &#123; i.getAndIncrement(); &#125;&#125; 我们来看getAndIncrement的内部：123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 再深入到getAndAddInt():12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 这里我们见到compareAndSwapInt这个函数，它也是CAS缩写的由来。那么仔细分析下这个函数做了什么呢？ 首先我们发现compareAndSwapInt前面的this，那么它属于哪个类呢，我们看上一步getAndAddInt，前面是unsafe。这里我们进入的Unsafe类。这里要对Unsafe类做个说明。结合AtomicInteger的定义来说：123456789101112public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(&quot;value&quot;)); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; 在AtomicInteger数据定义的部分，我们可以看到，其实实际存储的值是放在value中的，除此之外我们还获取了unsafe实例，并且定义了valueOffset。再看到static块，懂类加载过程的都知道，static块的加载发生于类加载的时候，是最先初始化的，这时候我们调用unsafe的objectFieldOffset从Atomic类文件中获取value的偏移量，那么valueOffset其实就是记录value的偏移量的。 再回到上面一个函数getAndAddInt，我们看var5获取的是什么，通过调用unsafe的getIntVolatile(var1, var2)，这是个native方法，具体实现到JDK源码里去看了，其实就是获取var1中，var2偏移量处的值。var1就是AtomicInteger，var2就是我们前面提到的valueOffset,这样我们就从内存里获取到现在valueOffset处的值了。 现在重点来了，compareAndSwapInt（var1, var2, var5, var5 + var4）其实换成compareAndSwapInt（obj, offset, expect, update）比较清楚，意思就是如果obj内的value和expect相等，就证明没有其他线程改变过这个变量，那么就更新它为update，如果这一步的CAS没有成功，那就采用自旋的方式继续进行CAS操作，取出乍一看这也是两个步骤了啊，其实在JNI里是借助于一个CPU指令完成的。所以还是原子操作。 CAS 的问题ABA问题 CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。这就是CAS的ABA问题。 常见的解决思路是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A-B-A 就会变成1A-2B-3A。 目前在JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大 上面我们说过如果CAS不成功，则会原地自旋，如果长时间自旋会给CPU带来非常大的执行开销。 参考https://juejin.im/post/5a73cbbff265da4e807783f5]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（十）]]></title>
    <url>%2F2020%2F04%2F12%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Java中用到的线程调度抢占式调度 抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。 协同式调度 协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。 JVM的线程调度实现（抢占式调度） java使用的线程调使用抢占式调度，Java中线程会按优先级分配CPU时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。 线程让出 cpu 的情况 当前运行线程主动放弃CPU，JVM暂时放弃CPU操作（基于时间片轮转调度的JVM操作系统不会让线程永久放弃CPU，或者说放弃本次时间片的执行权），例如调用yield()方法。 当前运行线程因为某些原因进入阻塞状态，例如阻塞在I/O 上。 当前运行线程结束，即运行完run()方法里面的任务。 进程调度算法优先调度算法 先来先服务调度算法（FCFS） 当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用FCFS算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。 短作业(进程)优先调度算法 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。 高优先权优先调度算法 为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。 非抢占式优先权算法 在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 抢占式优先权调度算法 在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。 高响应比优先调度算法 在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：Rp=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间(1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。(2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。(3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。 基于时间片的轮转调度算法 时间片轮转法 在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。与抢占式调度类似 多级反馈队列调度算法 (1) 应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第i+1个队列的时间片要比第i个队列的时间片长一倍。 (2) 当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行。 (3) 仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。 在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（九）]]></title>
    <url>%2F2020%2F04%2F11%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在两个线程之间共享数据 Java里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有三个：可见性和有序性、原子性。Java内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法： 将数据抽象成一个类，并将数据的操作作为这个类的方法 将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加”synchronized“123456789public class AddRunnable implements Runnable &#123; MyData data; public AddRunnable(MyData data) &#123; this.data = data; &#125; public void run() &#123; data.add(); &#125;&#125; 123456789public class DecRunnable implements Runnable &#123; MyData data; public DecRunnable(MyData data) &#123; this.data = data; &#125; public void run() &#123; data.dec(); &#125;&#125; 1234567891011121314151617181920212223public class MyData &#123; private int j = 0; public synchronized void add() &#123; j++; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;j 为：&quot; + j); &#125; public synchronized void dec() &#123; j--; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;j 为：&quot; + j); &#125; public int getData() &#123; return j; &#125; public static void main(String[] args) &#123; MyData data = new MyData(); Runnable add = new AddRunnable(data); Runnable dec = new DecRunnable(data); for (int i = 0; i &lt; 2; i++) &#123; new Thread(add).start(); new Thread(dec).start(); &#125; &#125;&#125; Runnable 对象作为一个类的内部类 将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法。1234567891011121314public class MyData &#123; private int j = 0; public synchronized void add() &#123; j++; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;j 为：&quot; + j); &#125; public synchronized void dec() &#123; j--; System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;j 为：&quot; + j); &#125; public int getData() &#123; return j; &#125;&#125; 1234567891011121314151617public class TestThread &#123; public static void main(String[] args) &#123; final MyData data = new MyData(); for (int i = 0; i &lt; 2; i++) &#123; new Thread(new Runnable() &#123; public void run() &#123; data.add(); &#125; &#125;).start(); new Thread(new Runnable() &#123; public void run() &#123; data.dec(); &#125; &#125;).start(); &#125; &#125;&#125; ThreadLocal作用（线程本地存储） ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 ThreadLocalMap（线程的一个属性） 每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 ThreadLocalMap 其实就是线程里面的一个属性，它在Thread类中定义ThreadLocal.ThreadLocalMap threadLocals = null; synchronized和ReentrantLock的区别两者的共同点 都是用来协调多线程对共享对象、变量的访问 都是可重入锁，同一线程可以多次获得同一个锁 都保证了可见性和互斥性 两者的不同点 ReentrantLock显示的获得、释放锁，synchronized隐式获得释放锁 ReentrantLock可响应中断、可轮回，synchronized是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 ReentrantLock是API级别的，synchronized是JVM级别的 ReentrantLock可以实现公平锁 ReentrantLock通过Condition可以绑定多个条件 底层实现不一样，synchronized是同步阻塞，使用的是悲观并发策略，lock是同步非阻塞，采用的是乐观并发策略 Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现。 synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁。 Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断。 通过Lock可以知道有没有成功获取锁，而 synchronized 却无法办到。 Lock可以提高多个线程进行读操作的效率，既就是实现读写锁等。 ConcurrentHashMap 并发减小锁粒度 减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是ConcurrentHashMap(高性能的HashMap)类的实现。对于HashMap而言，最重要的两个方法是get与set方法，如果我们对整个HashMap加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment的大小也被称为ConcurrentHashMap的并发度。 ConcurrentHashMap 分段锁 ConcurrentHashMap，它内部细分了若干个小的HashMap，称之为段(Segment)。默认情况下一个ConcurrentHashMap被进一步细分为16个段，既就是锁的并发度。 如果需要在ConcurrentHashMap中添加一个新的表项，并不是将整个HashMap加锁，而是首先根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁，并完成put操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构，一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（八）]]></title>
    <url>%2F2020%2F04%2F10%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[CyclicBarrier、CountDownLatch、Semaphore的用法CountDownLatch（线程计数器 ） CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。1234567891011121314151617181920212223242526272829final CountDownLatch latch = new CountDownLatch(2);new Thread() &#123; public void run() &#123; System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;正在执行&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;); latch.countDown(); &#125;;&#125;.start();new Thread() &#123; public void run() &#123; System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;正在执行&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;子线程&quot; + Thread.currentThread().getName() + &quot;执行完毕&quot;); latch.countDown(); &#125;;&#125;.start();System.out.println(&quot;等待 2 个子线程执行完毕...&quot;);latch.await();System.out.println(&quot;2 个子线程已经执行完毕&quot;);System.out.println(&quot;继续执行主线程&quot;); CyclicBarrier（回环栅栏-等待至barrier状态再全部同时执行） 字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。CyclicBarrier中最重要的方法就是await方法，它有2个重载版本： await()：用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务； await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。 具体使用如下，另外 CyclicBarrier 是可以重用的。1234567891011121314151617181920212223242526public static void main(String[] args) &#123; int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for (int i = 0; i &lt; N; i++) new Writer(barrier).start();&#125;static class Writer extends Thread &#123; private CyclicBarrier cyclicBarrier; public Writer(CyclicBarrier cyclicBarrier) &#123; this.cyclicBarrier = cyclicBarrier; &#125; @Override public void run() &#123; try &#123; Thread.sleep(5000); // 以睡眠来模拟线程需要预定写入数据操作 System.out.println(&quot;线程&quot; + Thread.currentThread().getName() + &quot;写入数据完毕，等待其他线程写入完毕&quot;); cyclicBarrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;所有线程写入完毕，继续处理其他任务，比如数据操作&quot;); &#125;&#125; Semaphore（信号量-控制同时访问的线程个数） Semaphore翻译成字面意思为信号量，Semaphore可以控制同时访问的线程个数，通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。Semaphore 类中比较重要的几个方法： public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 public void acquire(int permits):获取 permits 个许可 public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 public void release(int permits) { }:释放 permits个许可。 上面4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法： public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。 public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。 public boolean tryAcquire(int permits):尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false。 public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false。 还可以通过availablePermits()方法得到可用的许可数目。 例子：若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：123456789101112131415161718192021222324252627public static void main(String[] args) &#123; int N = 8; // 工人数 Semaphore semaphore = new Semaphore(5); // 机器数目 for (int i = 0; i &lt; N; i++) new Worker(i, semaphore).start();&#125;static class Worker extends Thread &#123; private int num; private Semaphore semaphore; public Worker(int num, Semaphore semaphore) &#123; this.num = num; this.semaphore = semaphore; &#125; @Override public void run() &#123; try &#123; semaphore.acquire(); System.out.println(&quot;工人&quot; + this.num + &quot;占用一个机器在生产...&quot;); Thread.sleep(2000); System.out.println(&quot;工人&quot; + this.num + &quot;释放出机器&quot;); semaphore.release(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同；CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。 Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（七）]]></title>
    <url>%2F2020%2F04%2F09%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA阻塞队列原理 阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况： 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。 阻塞队列的主要方法 方法类型 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e,time,unit) 移除 remove() poll() take() poll(time.unit) 检查 element() peek() 不可用 不可用 抛出异常：抛出一个异常；特殊值：返回一个特殊值（null 或 false,视情况而定）阻塞：在成功操作之前，一直阻塞线程超时：放弃前只在最大的时间内阻塞 插入操作 public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回true，如果当前没有可用的空间，则抛出IllegalStateException。如果该元素是 NULL，则会抛出NullPointerException异常。 public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回true，如果当前没有可用的空间，则返回false。 public abstract void put(E paramE) throws InterruptedException：将指定元素插入此队列中，将等待可用的空间（如果有必要） offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。 获取数据操作 poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,取不到时返回null; poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败 take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到BlockingQueue有新的数据被加入。 drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁 Java中的阻塞队列 ArrayBlockingQueue：由数组结构组成的有界阻塞队列。 LinkedBlockingQueue：由链表结构组成的有界阻塞队列。 PriorityBlockingQueue：支持优先级排序的无界阻塞队列。 DelayQueue：使用优先级队列实现的无界阻塞队列。 SynchronousQueue：不存储元素的阻塞队列。 LinkedTransferQueue：由链表结构组成的无界阻塞队列。 LinkedBlockingDeque：由链表结构组成的双向阻塞队列 ArrayBlockingQueue（公平、非公平） ArrayBlockingQueue用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true); LinkedBlockingQueue（两个独立锁提高并发） LinkedBlockingQueue基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。 LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 PriorityBlockingQueue（compareTo 排序实现优先） PriorityBlockingQueue是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。 DelayQueue（缓存失效、定时任务） DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景： 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。 SynchronousQueue（不存储数据、可用于传递数据） SynchronousQueue是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。SynchronousQueue可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用，SynchronousQueue的吞吐量高于LinkedBlockingQueue和ArrayBlockingQueue。 LinkedTransferQueue LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法。 transfer方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的poll()方法时），transfer方法可以把生产者传入的元素立刻transfer（传输）给消费者。如果没有消费者在等待接收元素，transfer方法会将元素存放在队列的tail节点，并等到该元素被消费者消费了才返回。 tryTransfer方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回false。和transfer方法的区别是tryTransfer方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。 对于带有时间限制的tryTransfer(E e,long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回false，如果在超时时间内消费了元素，则返回true。 LinkedBlockingDeque LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以Last单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法add等同于addLast，移除方法remove等效于removeFirst。但是take方法却等同于takeFirst，不知道是不是Jdk的bug，使用时还是用带有First和Last后缀的方法更清楚。 在初始化LinkedBlockingDeque时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。 工作窃取算法 工作窃取(work-stealing)算法是指某个线程从其他队列里窃取任务来执行。 一个大任务分割为若干个互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应。比如线程1负责处理1队列里的任务，2线程负责2队列的。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务待处理。干完活的线程与其等着，不如帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们可能会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务线程永远从双端队列的尾部拿任务执行。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（六）]]></title>
    <url>%2F2020%2F04%2F08%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线程上下文切换 巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。 进程 （有时候也称做任务）是指一个程序运行的实例。在Linux系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。 上下文 是指某一时间点CPU寄存器和程序计数器的内容。 寄存器 是CPU内部的数量较少但是速度很快的内存（与之对应的是CPU外部相对较慢的RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。 程序计数器 是一个专用的寄存器，用于表明指令序列中CPU正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。 PCB-“切换桢” 上下文切换可以认为是内核（操作系统的核心）在CPU上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。信息会一直保存到CPU的内存中，直到他们被再次使用。 上下文切换的活动 挂起一个进程，将这个进程在CPU中的状态（上下文）存储于内存中的某处。 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。 引起线程上下文切换的原因 当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； 当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务； 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务； 用户代码挂起当前任务，让出 CPU 时间； 硬件中断； 同步锁与死锁同步锁 当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。Java中可以使用synchronized关键字来取得一个对象的同步锁。 死锁 何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 线程池原理 线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。 线程复用 每一个Thread的类都有一个start方法。当调用start启动线程时Java虚拟机会调用该类的run方法。那么该类的run()方法中就是调用了Runnable对象的run()方法。 我们可以继承重写Thread类，在其start方法中添加不断循环调用传递过来的Runnable对象。这就是线程池的实现原理。循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的。 线程池的组成 一般的线程池主要分为以下4个组成部分： 线程池管理器：用于创建并管理线程池 工作线程：线程池中的线程 任务接口：每个任务必须实现的接口，用于工作线程调度其运行 任务队列：用于存放待处理的任务，提供一种缓冲机制 Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor，Callable和Future、FutureTask这几个类。 ThreadPoolExecutor的构造方法如下：12345public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize：指定了线程池中的线程数量。 maximumPoolSize：指定了线程池中的最大线程数量。 keepAliveTime：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。 unit：keepAliveTime的单位。 workQueue：任务队列，被提交但尚未被执行的任务。 threadFactory：线程工厂，用于创建线程，一般用默认的即可。 handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。 拒绝策略 线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。 JDK内置的拒绝策略如下： AbortPolicy：直接抛出异常，阻止系统正常运行。 CallerRunsPolicy：只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 DiscardOldestPolicy：丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。 以上内置拒绝策略均实现了RejectedExecutionHandler接口，若以上策略仍无法满足实际需要，完全可以自己扩展RejectedExecutionHandler接口。 Java线程池工作过程 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 当调用execute()方法添加一个任务时，线程池会做如下判断：a) 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；b) 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；c) 如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；d) 如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。 当一个线程完成任务时，它会从队列中取下一个任务来执行。 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize的大小。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（五）]]></title>
    <url>%2F2020%2F04%2F08%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[线程基本方法 线程相关的基本方法有wait，notify，notifyAll，sleep，join，yield等。 线程等待（wait） 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用wait()方法后，会释放对象的锁。因此，wait方法一般用在同步方法或同步代码块中。 线程睡眠（sleep） sleep导致当前线程休眠，与wait方法不同的是sleep不会释放当前占有的锁,sleep(long)会导致线程进入 TIMED-WATING 状态，而wait()方法会导致当前线程进入WATING状态 线程让步（yield） yield会使当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到CPU时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。 线程中断（interrupt） 中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)。 调用interrupt()方法并不会中断一个正在运行的线程。也就是说处于Running状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。 若调用sleep()而使线程处于TIMED-WATING状态，这时调用interrupt()方法，会抛出InterruptedException,从而使线程提前结束TIMED-WATING状态。 许多声明抛出InterruptedException的方法(如Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用isInterrupted()方法将会返回false。 中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread 的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以根据thread.isInterrupted()的值来优雅的终止线程。 Join等待其他线程终止 join()方法，等待其他线程终止，在当前线程中调用一个线程的join()方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待cpu的宠幸。 为什么要用join()方法？ 很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到join()方法。12345System.out.println(Thread.currentThread().getName() + &quot;线程运行开始!&quot;); Thread6 thread1 = new Thread6(); thread1.setName(&quot;线程 B&quot;); thread1.join();System.out.println(&quot;这时 thread1 执行完毕之后才能执行主线程&quot;); 线程唤醒（notify） Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个wait()方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有notifyAll()，唤醒再次监视器上等待的所有线程。 其他方法： sleep()：强迫一个线程睡眠Ｎ毫秒。 isAlive()：判断一个线程是否存活。 join()：等待线程终止。 activeCount()：程序中活跃的线程数。 enumerate()：枚举程序中的线程。 currentThread()：得到当前线程。 isDaemon()：一个线程是否为守护线程。 setDaemon()：设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) setName()：为线程设置一个名称。 wait()：强迫一个线程等待。 notify()：通知一个线程继续运行。 setPriority()：设置一个线程的优先级。 getPriority():获得一个线程的优先级。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（四）]]></title>
    <url>%2F2020%2F04%2F06%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA锁乐观锁 乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 java中的乐观锁基本都是通过 CAS 操作实现的，CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 即只有在写的时候才加锁 悲观锁 悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如RetreenLock。 无论读写，对象都要加锁 自旋锁 自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 线程自旋是需要消耗cup的，说白了就是让cup在做无用功，如果一直获取不到锁，那线程也不能一直占用cup自旋做无用功，所以需要设定一个自旋等待的最大时间。 如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 自旋锁的优缺点 自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！ 但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用cpu做无用功，占着茅坑不拉屎，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要cup的线程又不能获取到cpu，造成cpu的浪费。所以这种情况下我们要关闭自旋锁； 自旋锁时间阈值（1.6 引入了适应性自旋锁） 自旋锁的目的是为了占着CPU的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！ JVM对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在1.6引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前CPU的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过(CPUs/2)个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是CPU的存储延迟（CPU A存储了一个数据，到CPU B得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。 自旋锁的开启JDK1.6 中-XX:+UseSpinning 开启；-XX:PreBlockSpin=10 为自旋次数；JDK1.7 后，去掉此参数，由 jvm 控制。 Synchronized 同步锁 synchronized它可以把任意一个非NULL的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。 Synchronized 作用范围 作用于方法时，锁住的是对象的实例(this)； 当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程； synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。 Synchronized 核心组件 Wait Set：哪些调用wait方法被阻塞的线程被放置在这里； Contention List：竞争队列，所有请求锁的线程首先被放在这个竞争队列中； Entry List：Contention List中那些有资格成为候选资源的线程被移动到Entry List中； OnDeck：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为OnDeck； Owner：当前已经获取到所资源的线程被称为Owner； !Owner：当前释放锁的线程。 Synchronized 实现 JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下，ContentionList会被大量的并发线程进行CAS访问，为了降低对尾部元素的竞争，JVM会将一部分线程移动到EntryList中作为候选竞争线程。 Owner线程会在unlock时，将ContentionList中的部分线程迁移到EntryList中，并指定EntryList中的某个线程为OnDeck线程（一般是最先进去的那个线程）。 Owner线程并不直接把锁传递给OnDeck线程，而是把锁竞争的权利交给OnDeck，OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在JVM中，也把这种选择行为称之为“竞争切换”。 OnDeck线程获取到锁资源后会变为Owner线程，而没有得到锁资源的仍然停留在EntryList中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify或者notifyAll唤醒，会重新进去EntryList中。 处于 ContentionList、EntryList、WaitSet中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux内核下采用pthread_mutex_lock内核函数实现的）。 Synchronized是非公平锁。Synchronized在线程进入ContentionList时，等待的线程会先尝试自旋获取锁，如果获取不到就进入ContentionList，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占OnDeck线程的锁资源。参考：https://blog.csdn.net/zqz_zqz/article/details/70233767 每个对象都有个monitor对象，加锁就是在竞争monitor对象，代码块加锁是在前后分别加上monitorenter和monitorexit指令来实现的，方法加锁是通过一个标记位来判断的 synchronized是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7与1.8中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。 锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。这种升级过程叫做锁膨胀； JDK1.6中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking来禁用偏向锁。 ReentrantLock ReentantLock继承接口Lock并实现了接口中定义的方法，他是一种可重入锁，除了能完成synchronized所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。 Lock 接口的主要方法 void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. boolean tryLock()：如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false. 该方法和lock()的区别在于,tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用,当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生. Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将缩放锁。 getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数。 getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动10个线程，1个线程获得锁，此时返回的是9 getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如10个线程，用同一个condition对象，并且此时这10个线程都执行了condition对象的await方法，那么此时执行此方法返回10 hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定contidion对象，有多少线程执行了condition.await方法 hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 hasQueuedThreads()：是否有线程等待此锁 isFair()：该锁是否公平锁 isHeldByCurrentThread()：当前线程是否保持锁锁定，线程的执行lock方法的前后分别是false和true isLock()：此锁是否有任意线程占用 lockInterruptibly（）：如果当前线程未被中断，获取锁 tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。 非公平锁 JVM按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。 公平锁 公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，ReentrantLock在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 ReentrantLock 与 synchronized ReentrantLock通过方法 lock()与unlock()来进行加锁与解锁操作，与synchronized会被JVM自动解锁机制不同，ReentrantLock加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用ReentrantLock必须在finally控制块中进行解锁操作。 ReentrantLock相比synchronized的优势是可中断、公平锁、多个锁。这种情况下需要使用ReentrantLock。 锁的实现： Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的，有什么区别，说白了就类似于操作系统来控制实现和用户自己敲代码实现的区别。前者的实现是比较难见到的，后者有直接的源码可供阅读。 性能的区别： 在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。 功能区别： 便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。 锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized ReenTrantLock独有的能力： ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。 ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。 ReenTrantLock实现的原理： 简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。 ReentrantLock 实现123456789101112131415161718192021222324252627import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;public class MyService &#123; private Lock lock = new ReentrantLock(); // Lock lock=new ReentrantLock(true);//公平锁 // Lock lock=new ReentrantLock(false);//非公平锁 private Condition condition = lock.newCondition();// 创建 Condition public void testMethod() &#123; try &#123; lock.lock();// lock 加锁 // 1：wait 方法等待： // System.out.println(&quot;开始 wait&quot;); condition.await(); // 通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁 // :2：signal 方法唤醒 condition.signal();// condition 对象的 signal 方法可以唤醒 wait 线程 for (int i = 0; i &lt; 5; i++) &#123; System.out.println(&quot;ThreadName=&quot; + Thread.currentThread().getName() + (&quot; &quot; + (i + 1))); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; Condition类和Object类锁方法区别区别 Condition类的awiat方法和Object类的wait方法等效 Condition类的signal方法和Object类的notify方法等效 Condition类的signalAll方法和Object类的notifyAll方法等效 ReentrantLock类可以唤醒指定条件的线程，而object的唤醒是随机的 tryLock和lock和lockInterruptibly的区别 tryLock能获得锁就返回true，不能就立即返回false，tryLock(long timeout,TimeUnitunit)，可以增加时间限制，如果超过该时间段还没获得锁，返回false lock能获得锁就返回true，不能的话一直等待获得锁 lock和lockInterruptibly，如果两个线程分别执行这两个方法，但此时中断这两个线程，lock不会抛出异常，而lockInterruptibly会抛出异常。 Semaphore信号量 Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池 实现互斥锁（计数器为 1） 我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。 代码实现1234567891011121314// 创建一个计数阈值为 5 的信号量对象// 只能 5 个线程同时访问Semaphore semp = new Semaphore(5);try &#123; // 申请许可 semp.acquire(); try &#123; // 业务逻辑 &#125; catch (Exception e) &#123; &#125; finally &#123; // 释放许可 semp.release(); &#125;&#125; catch (InterruptedException e) &#123;&#125; Semaphore与ReentrantLock Semaphore基本能完成ReentrantLock的所有工作，使用方法也与之类似，通过acquire()与release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。 此外，Semaphore也实现了可轮询的锁请求与定时锁的功能，除了方法名tryAcquire与tryLock不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 Semaphore的锁释放操作也由手动进行，因此与ReentrantLock一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在finally代码块中完成。 AtomicInteger AtomicInteger是一个提供原子操作的Integer的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference等，他们的实现原理相同，区别在与运算对象类型的不同。另外，还可以通过AtomicReference将一个对象的所有操作转化成原子操作。 我们知道，在多线程程序中，诸如++i或i++等运算不具有原子性，是不安全的线程操作之一。通常我们会使用synchronized将该操作变成一个原子操作，但JVM为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger的性能是ReentantLock的好几倍。 可重入锁（递归锁） 本文里面讲的是广义上的可重入锁，而不是单指JAVA下的ReentrantLock。 可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在JAVA环境下ReentrantLock和synchronized都是可重入锁。 公平锁与非公平锁公平锁（Fair） 加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 非公平锁（Nonfair） 加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待。 非公平锁性能比公平锁高5~10倍，因为公平锁需要在多核的情况下维护一个队列。 Java中的synchronized是非公平锁，ReentrantLock 默认的lock()方法采用的是非公平锁。 ReadWriteLock 读写锁 为了提高性能，Java提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 读锁 如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 写锁 如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ Java中读写锁有个接口java.util.concurrent.locks.ReadWriteLock ，也有具体的实现ReentrantReadWriteLock。 共享锁和独占锁 java并发包提供的加锁模式分为独占锁和共享锁。 独占锁 独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock就是以独占方式实现的互斥锁。 独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。 共享锁 共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。 AQS的内部类 Node 定义了两个常量SHARED和EXCLUSIVE，他们分别标识AQS队列中等待线程的锁获取模式。 java的并发包中提供了ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。重量级锁（Mutex Lock） Synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的Mutex Lock来实现的。 而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。 因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。JDK中对Synchronized做的种种优化，其核心都是为了减少这种重量级锁的使用。 JDK1.6以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。轻量级锁 锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁锁升级 随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。 “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。偏向锁 Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。分段锁 分段锁也并非一种实际的锁，而是一种思想ConcurrentHashMap是学习分段锁的最好实践。 锁优化减少锁持有时间 只用在有线程安全要求的程序上加锁 减小锁粒度 将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是ConcurrentHashMap。 锁分离 最常见的锁分离就是读写锁ReadWriteLock，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]JDK并发包1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue从头部取出，从尾部放数据。 锁粗化 通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。 锁消除 锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。ps:参考https://www.jianshu.com/p/39628e1180a9]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页变灰原理]]></title>
    <url>%2F2020%2F04%2F05%2F%E7%BD%91%E9%A1%B5%E5%8F%98%E7%81%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[4月4号为纪念抗疫牺牲的人员，全国停摆，早上10点钟鸣钟，默哀3分钟。其中大多数网站都变成了灰色。 网页变灰原理技术原理很简单，在网页element.style中，加上filter: grayscale(100%);属性就行。表示该网页所有标签100%灰度，包括图片。 其他filter那么css中还有其他滤镜属性吗？ Filter 描述 none 默认值，没有效果。 blur(px) 给图像设置高斯模糊。”radius”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊；如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。 brightness(%) 给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。 contrast(%) 调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。 drop-shadow(h-shadow v-shadow blur spread color) 给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受&lt;shadow&gt;(在CSS3背景中定义)类型的值，除了”inset”关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。&lt;shadow&gt;参数如下： &lt;offset-x&gt; &lt;offset-y&gt; (必须) 这是设置阴影偏移量的两个 &lt;length&gt;值. &lt;offset-x&gt;&nbsp;设定水平方向距离. 负值会使阴影出现在元素左边. &lt;offset-y&gt;设定垂直距离.负值会使阴影出现在元素上方。查看&lt;length&gt;可能的单位. 如果两个值都是0, 则阴影出现在元素正后面 (如果设置了&nbsp;&lt;blur-radius&gt;&nbsp;and/or&nbsp;&lt;spread-radius&gt;，会有模糊效果). &lt;blur-radius&gt; (可选) 这是第三个code&gt;&lt;length&gt;值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0&nbsp;(则阴影的边界很锐利). &lt;spread-radius&gt; (可选) 这是第四个 &lt;length&gt;值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0&nbsp;(阴影会与元素一样大小).&nbsp; 注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。 &nbsp; &lt;color&gt; (可选) 查看 &lt;color&gt;该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko&nbsp;(Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用colorcolor属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。 grayscale(%) 将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0； hue-rotate(deg) 给图像应用色相旋转。”angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。 invert(%) 反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。 opacity(%) 转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。 saturate(%) 转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。 sepia(%) 将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0； url() URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。 例如： filter: url(svg-url#element-id) initial 设置属性为默认值 inherit 从父元素继承该属性 参考https://www.runoob.com/cssref/css3-pr-filter.html]]></content>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（三）]]></title>
    <url>%2F2020%2F04%2F05%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[终止线程4种方式正常运行结束程序运行结束，线程自动结束。 使用退出标志退出线程一般run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程。本质上也是乘车运行结束。 Interrupt方法结束线程使用 interrupt()方法来中断线程有两种情况： 线程处于阻塞状态：如使用了sleep,同步锁的 wait,socket中的receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。 线程未处于阻塞状态：使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。 stop方法终止线程（线程不安全，不建议）程序中可以直接使用thread.stop()来强行终止线程，但是stop方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是：thread.stop()调用之后，创建子线程的线程就会抛出ThreadDeatherror的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在调用thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用stop方法来终止线程。 sleep与wait区别 对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。 sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。 在调用sleep()方法的过程中，线程不会释放对象锁。 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。 start与run区别 start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码。 通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。 方法run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，开始运行run函数当中的代码。Run方法运行结束，此线程终止，然后CPU再调度其它线程。 JAVA 后台线程守护线程–也称“服务线程”，他是后台线程，它有一个特性，即为用户线程提供公共服务，在没有用户线程可服务时会自动离开。 优先级守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。 设置通过setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在线程对象创建之前用线程对象的setDaemon方法。在Daemon线程中产生的新线程也是Daemon的。 其他线程则是JVM级别的，以Tomcat为例，如果你在Web应用中启动一个线程，这个线程的生命周期并不会和Web应用程序保持同步。也就是说，即使你停止了Web应用，这个线程依旧是活跃的。 应用垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 生命周期守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（二）]]></title>
    <url>%2F2020%2F04%2F03%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[java线程池Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 4种线程池newCachedThreadPool创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用execute将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有60秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。 newFixedThreadPool创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数nThreads线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 newScheduledThreadPool创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。12345678910111213ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);scheduledThreadPool.schedule(newRunnable()&#123;@Overridepublic void run() &#123; System.out.println(&quot;延迟三秒&quot;);&#125;&#125;, 3, TimeUnit.SECONDS);scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123;@Overridepublic void run() &#123; System.out.println(&quot;延迟 1 秒后每三秒执行一次&quot;);&#125;&#125;,1,3,TimeUnit.SECONDS); newSingleThreadExecutorExecutors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去。 线程生命周期(状态)当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。 新建状态（NEW）当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值。 就绪状态（RUNNABLE）当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。 运行状态（RUNNING）如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态。 阻塞状态（BLOCKED）阻塞状态是指线程因为某种原因放弃了cpu使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice转到运行(running)状态。阻塞的情况分三种： 等待阻塞（o.wait-&gt;等待对列）运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。 同步阻塞(lock-&gt;锁池运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。 其他阻塞(sleep/join)运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O 请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。 线程死亡（DEAD）线程会以下面三种方式结束，结束后就是死亡状态。 正常结束run()或 call()方法执行完成，线程正常结束。 异常结束线程抛出一个未捕获的 Exception 或 Error。 调用stop直接调用该线程的stop()方法来结束该线程—该方法通常容易导致死锁，不推荐使用。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程（一）]]></title>
    <url>%2F2020%2F04%2F02%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JAVA 线程实现/创建方式继承Thread类Thread类本质上是实现了Runnable接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过Thread类的 start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。1234567public class MyThread extends Thread &#123; public void run() &#123; System.out.println(&quot;MyThread.run()&quot;); &#125;&#125;MyThread myThread1 = new MyThread();myThread1.start(); 实现Runnable接口如果自己的类已经extends另一个类，就无法直接extends Thread，此时，可以实现一个Runnable接口。12345678910111213141516public class MyThread extends OtherClass implements Runnable &#123; public void run() &#123; System.out.println(&quot;MyThread.run()&quot;); &#125;&#125;//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：MyThread myThread = new MyThread();Thread thread = new Thread(myThread);thread.start();//事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用target.run()public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; ExecutorService、Callable、Future 有返回值线程有返回值的任务必须实现Callable接口，类似的，无返回值的任务必须Runnable接口。执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。1234567891011121314151617//创建一个线程池ExecutorService pool = Executors.newFixedThreadPool(taskSize);// 创建多个有返回值的任务List&lt;Future&gt; list = new ArrayList&lt;Future&gt;();for (int i = 0; i &lt; taskSize; i++) &#123; Callable c = new MyCallable(i + &quot; &quot;); // 执行任务并获取 Future 对象 Future f = pool.submit(c); list.add(f);&#125;// 关闭线程池pool.shutdown();// 获取所有并发任务的运行结果for (Future f : list) &#123; // 从 Future 对象上获取任务的返回值，并输出到控制台 System.out.println(&quot;res：&quot; + f.get().toString());&#125; 基于线程池的方式线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。12345678910111213141516// 创建线程池ExecutorService threadPool = Executors.newFixedThreadPool(10); while(true) &#123; threadPool.execute(new Runnable() &#123; // 提交多个线程任务，并执行 @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + &quot; is running ..&quot;); try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA集合]]></title>
    <url>%2F2020%2F04%2F01%2FJAVA%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[接口继承关系和实现集合类存放于 Java.util包中，主要有3种：set(集）、list(列表包含 Queue）和 map(映射)。 Collection：Collection是集合 List、Set、Queue的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据。 Map：是映射表的基础接口。 ListJava的List是非常常用的数据类型。List是有序的Collection。Java List一共三个实现类：分别是ArrayList、Vector和LinkedList。 ArrayList（数组）ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector（数组实现、线程同步）Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。 LinkList（链表）LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 SetSet注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。对象的相等性本质是对象hashCode值（java是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖Object的hashCode方法和equals方法。 HashSet（Hash表）哈希表边存放的是哈希值。HashSet存储元素的顺序并不是按照存入时的顺序（和List显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode方法来获取的, HashSet首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals方法 如果equls结果为true，HashSet就视为同一个元素。如果equals为false就不是同一个元素。哈希值相同equals为false的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。HashSet通过hashCode值来确定元素在内存中的位置。一个hashCode位置上可以存放多个元素。 TreeSet（二叉树）TreeSet()是使用二叉树的原理对新add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。Integer和String对象都可以进行默认的TreeSet排序，而自定义类的对象是不可以的，自己定义的类必须实现Comparable接口，并且覆写相应的compareTo()函数，才可以正常使用。在覆写compare()函数时，要返回相应的值才能使TreeSet按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkHashSet（HashSet+LinkedHashMap）对于LinkedHashSet而言，它继承于HashSet、又基于LinkedHashMap来实现的。LinkedHashSet底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上又与HashSet相同，因此LinkedHashSet的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个LinkedHashMap来实现，在相关操作上与父类HashSet的操作相同，直接调用父类HashSet的方法即可。 MapHashMap（数组+链表+红黑树）HashMap根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 ConcurrentHashMap（线程安全）Segment段ConcurrentHashMap和HashMap思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个ConcurrentHashMap由一个个Segment组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个segment。线程安全（Segment 继承 ReentrantLock 加锁）简单理解就是，ConcurrentHashMap是一个Segment数组，Segment通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个segment，这样只要保证每个Segment是线程安全的，也就实现了全局的线程安全。并行度（默认16）concurrencyLevel：并行级别、并发数、Segment数，怎么翻译不重要，理解它。默认是 16，也就是说ConcurrentHashMap有16个Segments，所以理论上，这个时候，最多可以同时支持16个线程并发写，只要它们的操作分别分布在不同的Segment上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个Segment内部，其实每个Segment很像之前介绍的HashMap，不过它要保证线程安全，所以处理起来要麻烦些。Java8实现（引入了红黑树）Java8对ConcurrentHashMap进行了比较大的改动,引入了红黑树。 HashTable（线程安全，不建议使用）Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。 TreeMap（可排序）TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 LinkHashMap（记录插入顺序）LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM（五）--类加载机制]]></title>
    <url>%2F2020%2F03%2F31%2FJVM%EF%BC%88%E4%BA%94%EF%BC%89--%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[JVM类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这五个过程。 加载加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 验证这一阶段的主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：1public static int v = 8080; 实际上变量v在准备阶段过后的初始值为0而不是8080，将v赋值为8080的put static指令是程序被编译后，存放于类构造器方法之中。但是注意如果声明为：1public static final int v = 8080; 在编译阶段会为v生成ConstantValue属性，在准备阶段虚拟机会根据ConstantValue属性将v赋值为8080。 解析解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是class文件中的：123CONSTANT_Class_infoCONSTANT_Field_infoCONSTANT_Method_info 等类型的常量。 符号引用符号引用与虚拟机实现的布局无关，引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 直接引用直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。 初始化初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。 类构造器初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕，如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取Class对象，不会触发类的初始化。 通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过ClassLoader默认的loadClass方法，也不会触发初始化动作。 类加载器虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器： 启动类加载器(Bootstrap ClassLoader)负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。 扩展类加载器(Extension ClassLoader)负责加载 JAVA_HOME\lib\ext目录中的，或通过java.ext.dirs系统变量指定路径中的类库。 应用程序类加载器(Application ClassLoader)负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双亲委派和破坏双亲委派]]></title>
    <url>%2F2020%2F03%2F28%2F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[对于任意一个类，都需要由加载它的类加载器和这个类本身来一同确立其在Java虚拟机中的唯一性。如果不是同一个类加载器加载，即时是相同的class文件，也会出现判断不相同的情况，从而引发一些意想不到的情况，为了保证相同的class文件，在使用的时候，是相同的对象，jvm设计的时候，采用了双亲委派的方式来加载类。 双亲委派如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。 系统加载器 启动类加载器（Bootstrap ClassLoader）：C++实现，在java里无法获取，负责加载&lt;JAVA_HOME&gt;/lib下的类。 扩展类加载器（Extension ClassLoader）： Java实现，可以在java里获取，负责加载&lt;JAVA_HOME&gt;/lib/ext下的类。 系统类加载器/应用程序类加载器（Application ClassLoader）：是与我们接触最多的类加载器，我们写的代码默认就是由它来加载，ClassLoader.getSystemClassLoader返回的就是它。三者之间关系是：启动类加载器（Bootstrap ClassLoader） &lt;== 扩展类加载器（Extension ClassLoader） &lt;== 应用程序类加载器（Application ClassLoader） &lt;== 自定义类加载器（User ClassLoader） 破坏双亲委派为什么需要破坏双亲委派？因为在某些情况下父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器无法加载到需要的文件，以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，而其实现是由服务商提供的，由系统类加载器加载，这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。 破坏双亲委派的实现结合Driver来看一下在spi（Service Provider Inteface）中如何实现破坏双亲委派。先从DriverManager开始看，平时我们通过DriverManager来获取数据库的Connection：12String url = &quot;jdbc:mysql://localhost:3306/testdb&quot;;Connection conn = java.sql.DriverManager.getConnection(url, &quot;root&quot;, &quot;root&quot;); 在调用DriverManager的时候，会先初始化类，调用其中的静态块：123456789101112131415161718192021222324static &#123; loadInitialDrivers(); println(&quot;JDBC DriverManager initialized&quot;);&#125;private static void loadInitialDrivers() &#123; ... // 加载Driver的实现类 AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try&#123; while(driversIterator.hasNext()) &#123; driversIterator.next(); &#125; &#125; catch(Throwable t) &#123; &#125; return null; &#125; &#125;); ...&#125; 重点来看一下ServiceLoader.load(Driver.class)：12345public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123; // 获取当前线程中的上下文类加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl);&#125; 可以看到，load方法调用获取了当前线程中的上下文类加载器，那么上下文类加载器放的是什么加载器呢？12345678910public Launcher() &#123; ... try &#123; this.loader = Launcher.AppClassLoader.getAppClassLoader(var1); &#125; catch (IOException var9) &#123; throw new InternalError(&quot;Could not create application class loader&quot;, var9); &#125; Thread.currentThread().setContextClassLoader(this.loader); ...&#125; 在sun.misc.Launcher中，我们找到了答案，在Launcher初始化的时候，会获取AppClassLoader，然后将其设置为上下文类加载器，而这个AppClassLoader，就是之前上文提到的系统类加载器Application ClassLoader，所以上下文类加载器默认情况下就是系统加载器。继续来看下ServiceLoader.load(service, cl)：1234567891011121314151617public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader)&#123; return new ServiceLoader&lt;&gt;(service, loader);&#125;private ServiceLoader(Class&lt;S&gt; svc, ClassLoader cl) &#123; service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;); // ClassLoader.getSystemClassLoader()返回的也是系统类加载器 loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl; acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null; reload();&#125;public void reload() &#123; providers.clear(); lookupIterator = new LazyIterator(service, loader);&#125; 上面这段就不解释了，比较简单，然后就是看LazyIterator迭代器：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980private class LazyIterator implements Iterator&lt;S&gt;&#123; // ServiceLoader的iterator()方法最后调用的是这个迭代器里的next public S next() &#123; if (acc == null) &#123; return nextService(); &#125; else &#123; PrivilegedAction&lt;S&gt; action = new PrivilegedAction&lt;S&gt;() &#123; public S run() &#123; return nextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; private S nextService() &#123; if (!hasNextService()) throw new NoSuchElementException(); String cn = nextName; nextName = null; Class&lt;?&gt; c = null; // 根据名字来加载类 try &#123; c = Class.forName(cn, false, loader); &#125; catch (ClassNotFoundException x) &#123; fail(service, &quot;Provider &quot; + cn + &quot; not found&quot;); &#125; if (!service.isAssignableFrom(c)) &#123; fail(service, &quot;Provider &quot; + cn + &quot; not a subtype&quot;); &#125; try &#123; S p = service.cast(c.newInstance()); providers.put(cn, p); return p; &#125; catch (Throwable x) &#123; fail(service, &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;, x); &#125; throw new Error(); // This cannot happen &#125; public boolean hasNext() &#123; if (acc == null) &#123; return hasNextService(); &#125; else &#123; PrivilegedAction&lt;Boolean&gt; action = new PrivilegedAction&lt;Boolean&gt;() &#123; public Boolean run() &#123; return hasNextService(); &#125; &#125;; return AccessController.doPrivileged(action, acc); &#125; &#125; private boolean hasNextService() &#123; if (nextName != null) &#123; return true; &#125; if (configs == null) &#123; try &#123; // 在classpath下查找META-INF/services/java.sql.Driver名字的文件夹 // private static final String PREFIX = &quot;META-INF/services/&quot;; String fullName = PREFIX + service.getName(); if (loader == null) configs = ClassLoader.getSystemResources(fullName); else configs = loader.getResources(fullName); &#125; catch (IOException x) &#123; fail(service, &quot;Error locating configuration files&quot;, x); &#125; &#125; while ((pending == null) || !pending.hasNext()) &#123; if (!configs.hasMoreElements()) &#123; return false; &#125; pending = parse(service, configs.nextElement()); &#125; nextName = pending.next(); return true; &#125;&#125; 整个流程 Launcher初始化，将AppClassLoader设置为ContextClassLoader 获取ContextClassLoader调用ServiceLoader.load(xxx.class,loader) 初始化ServiceLoader,LazyIterator 调用LazyIterator.hasNext(),在classpath下的META-INF/services/查找对应的xx接口的文件 调用LazyIterator.next(),用APPClassLoader和全限定名来加载实现类]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO/NIO (一)]]></title>
    <url>%2F2020%2F03%2F28%2FIO%E5%92%8CNIO%20(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[阻塞IO模型最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。典型的阻塞IO模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在read方法。 非阻塞IO模型当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。典型的非阻塞IO模型一般如下：1234567while(true)&#123; data = socket.read(); if(data!= error)&#123; // 处理数据 break; &#125;&#125; 但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。 多路复用IO模型多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。 信号驱动IO模型在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。 异步 IO 模型异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。注意，异步IO是需要操作系统的底层支持，在Java7中，提供了Asynchronous IO。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM（四）--收集算法和GC垃圾收集器]]></title>
    <url>%2F2020%2F03%2F27%2FJVM%EF%BC%88%E5%9B%9B%EF%BC%89--%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[GC 分代收集算法 VS 分区收集算法分代收集算法当前主流 VM 垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据对象存活周期的不同将内存划分为几块, 如 JVM 中的 新生代、老年代、永久代，这样就可以根据各年代特点分别采用最适当的 GC 算法。在新生代-复制算法每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量存活对象的复制成本就可以完成收集。在老年代-标记整理算法因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用“标记—清理”或“标记—整理”算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存。 分区收集算法分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是整个堆), 从而减少一次 GC 所产生的停顿。 GC垃圾收集器Java堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此java虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器。 Serial垃圾收集器（单线程、复制算法）Serial（英文连续）是最基本垃圾收集器，使用复制算法，曾经是JDK1.3.1之前新生代唯一的垃圾收集器。Serial是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial垃圾收集器依然是 java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器。 ParNew垃圾收集器（Serial+多线程）ParNew垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。ParNew收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限制垃圾收集器的线程数。【Parallel：平行的】ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。 Parallel Scavenge收集器（多线程复制算法、高效）Parallel Scavenge收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器，它重点关注的是程序达到一个可控制的吞吐量（Thoughput，CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。 Serial Old收集器（单线程标记整理算法 ）Serial Old是Serial垃圾收集器年老代版本，它同样是个单线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的年老代垃圾收集器。在Server 模式下，主要有两个用途： 在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。 作为年老代中使用CMS收集器的后备垃圾收集方案。 Parallel Old 收集器（多线程标记整理算法）Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6才开始提供。在JDK1.6之前，新生代使用ParallelScavenge收集器只能搭配年老代的 Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量，Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。 CMS 收集器（多线程标记清除算法）Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： 初始标记只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 并发标记进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 重新标记为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。 并发清除清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。 G1 收集器Garbage first垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS收集器，G1收集器两个最突出的改进是： 基于标记-整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM（三）--java四种引用类型]]></title>
    <url>%2F2020%2F03%2F26%2FJVM%EF%BC%88%E4%B8%89%EF%BC%89--java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[强引用在 Java 中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。 软引用软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 弱引用弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。 虚引用虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。虚引用的主要作用是跟踪对象被垃圾回收的状态。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM（二）--JVM运行时内存]]></title>
    <url>%2F2020%2F03%2F25%2FJVM%EF%BC%88%E4%BA%8C%EF%BC%89--JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[Java堆从GC的角度可以细分为: 新生代(Eden区、From Survivor区和 To Survivor区)和老年代。 新生代新生代是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。 Eden 区Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 ServivorFrom上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 ServivorTo 保留了一次 MinorGC 过程中的幸存者。 MinorGC的过程（复制-&gt;清空-&gt;互换）MinorGC 采用复制算法 eden、servicorFrom 复制到 ServicorTo，年龄+1首先，把Eden和ServivorFrom 区域中存活的对象复制到ServicorTo区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）； 清空 eden、servicorFrom然后，清空 Eden 和 ServicorFrom 中的对象； ServicorTo 和 ServicorFrom 互换最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。 老年代 主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。 MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。 永久代 指内存的永久保存区域，主要存放 Class和Meta（元数据）的信息,Class 在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC 不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。类的元数据放入 nativememory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。 如何确定垃圾引用计数法在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。 可达性分析为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。 标记清除算法（Mark-Sweep）最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。 复制算法（copying）为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。 标记整理算法(Mark-Compact)结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。 分代收集算法分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(YoungGeneration)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。 新生代与复制算法目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1:1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。 老年代与标记复制算法而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)，它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，EdenSpace 和 From Space区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM（一）--JVM的内存模型]]></title>
    <url>%2F2020%2F03%2F24%2FJVM%EF%BC%88%E4%B8%80%EF%BC%89--JVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概念JVMJVM是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆和一个存储方法域。 JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 程序计数器(线程私有)一块较小的内存空间, 是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如果还是 Native 方法，则为空。这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 虚拟机栈(线程私有)虚拟机栈是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接(Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。 本地方法区(线程私有)本地方法区和 Java Stack 作用类似, 区别是虚拟机栈为执行 Java 方法服务, 而本地方法栈则为Native 方法服务,如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用, 那么该栈将会是一个C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 堆（Heap-线程共享）-运行时数据区堆是被线程共享的一块内存区域，创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域。由于现代VM 采用分代收集算法, 因此 Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、From Survivor区和To Survivor区)和老年代。 方法区/永久代（线程共享） 我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小)。运行时常量池（Runtime Constant Pool）是方法区的一部分。 Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。 java转换流程Java 源文件—-&gt;编译器—-&gt;字节码文件—-&gt;JVM—-&gt;机器码 运行时数据区===&gt;类加载器子系统方法区，虚拟机栈，本地方法栈,堆，程序计数器 JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区域【JAVA 堆、方法区】、直接内存。 线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 HotspotVM 内, 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的生/死对应)。 线程共享区域随虚拟机的启动/关闭而创建/销毁。 直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel与Buffer的IO方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展),这样就避免了在 Java堆和 Native 堆中来回复制数据, 因此在一些场景中可以显著提高性能。 执行引擎==&gt;本地方法库 即时编译器，垃圾收集 线程定义这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程 有直接的映射关系。当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run()方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。 Hotspot JVMjvm和hotspot的联系与区别: JVM是虚拟机，总的来说是一种标准规范，虚拟机有很多实现版本。主要作用就是运行java的类文件的。 而HotSpot是虚拟机的一种实现,它是sun公司开发的,是sun jdk和open jdk中自带的虚拟机，也是目前使用范围最广的虚拟机。 HotSpot，顾名思义，它是基于热点代码探测的，有JIT即时编译功能，能提供更高质量的本地代码。 二者区别是一个是标准，一个是实现方式。 hotspot是jvm的一种具体实现。 Hotspot JVM 后台运行的系统线程主要有下面几个： 进程 作用 虚拟机线程（VM thread） 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。 周期性任务线程 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。 GC 线程 这些线程支持 JVM 中不同的垃圾回收活动。 编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。 信号分发线程 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理]]></content>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized、锁、同步]]></title>
    <url>%2F2020%2F02%2F28%2Fsynchronized%E3%80%81%E9%94%81%E3%80%81%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[synchronized介绍synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种： 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象； 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。 在用synchronized修饰方法时要注意以下几点： synchronized关键字不能继承。如果在父类中的某个方法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized关键字才可以。 定义接口方法时不能使用synchronized关键字。 构造方法不能使用synchronized关键字，但可以使用synchronized代码块来进行同步。 总结 无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。 每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制 synchronized与Lock的区别 首先synchronized是java内置关键字，在jvm层面，Lock是个java类； synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁； synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁； 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了； synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可） Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[valatile关键字]]></title>
    <url>%2F2020%2F02%2F12%2Fvalatile%2F</url>
    <content type="text"><![CDATA[起两个作用 内存的可见性在程序工作的过程中，会存在工作内存（比如多线程工作时的变量内存）和主内存，在修改完这个线程对象的一瞬间，该线程的工作内存已经改变，主内存还没有改变，其他线程可能存在数据不一致的问题使用valatile修饰后，该对象会立刻刷新到主内存和其他工内存。 顺序性，防止指令重排序。java在重新编译后，为了优化，字节码的顺序可能和我们所定义的顺序不一致，加上valatile，可以避免这种情况。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式vs继承]]></title>
    <url>%2F2020%2F02%2F12%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8Fvs%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[介绍装饰模式又名包装（Wrapper）模式 装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案 装饰模式以对客户透明的方式动态的给一个对象附加更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。 装饰模式可以在不创造更多子类的情况下。将对象的功能甲乙扩展。 装饰模式吧客户端的调用委派到被装饰类。装饰模式的关键在于这种扩展完全是透明的 装饰模式是在不必改变原类文件和使用继承的情况下，动态的扩展一个对象的功能。他是通过创建一个包装对象，也就是装饰来包裹真实的对象。 装饰模式的角色： 抽象构建角色（component）：给出一个抽象接口，以规范准备接受附加责任的对象。 具体构建角色（concrete Component）：定义一个将要接受附加责任的类。 装饰角色（Devorator）：持有一个构建对象的引用，并定义一个与抽象构建接口一致的接口。 具体装饰角色（Concrete Decorator）:负责给构建对象“贴上”附加的责任。 装饰模式的特点： 装饰对象和真实对象有相同的接口。这样客户端对象就可以以和真实对象相同的方式和装饰对象交互。 装饰对象包含一个真实对象的引用。 装饰对象接受所有来自客户端的请求。它把这些请求转发给真实的对象。 装饰对象可以在转发这些请求以前或者以后增加一些附加功能。这样就确保了在运行时，不用修改给定对象的结构就可以在外部增加附加的功能。在面向对象的设计中，通常是通过继承来是想对给定类的功能扩展。 核心代码：12345678910111213141516public interface Component&#123; void doSomething();&#125;public class Decoraror implements Component&#123; private Component component; public Decorator(Component component)&#123; this.component = component; &#125; public void doSomething()&#123; component.doSomething(); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发经验总结]]></title>
    <url>%2F2020%2F02%2F10%2F%E5%BC%80%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[接口返回的数据在数据库对应字符串，最好不好返回boolean类型，返回int或者string，考虑到安全的话，不要讲数据库代表的数字含义直接返回，如： 数据库是 1：成功；0：失败，返回时可以返回”success”:成功 ; “failure”:失败，返回时可以返回 对于数据库内容一定要有追溯性，不能为了业务方便，直接按照业务执行。 如查询记录一些日志，与其他冲突时，先删除以前全部的相关日志，再新增。（属于设计问题） 魔鬼数字，不要写成 STRING_1=”1” ,这种写法还是属于魔鬼数字，STRING_1代表什么含义还是不知道，不能偷懒。 对于if条件，如果是两种情况，且确认值的情况下，需要全部判断(特别复杂的除外，如多个条件同时判断，多个条件结果重复)。如： 字符串str可能是1或者2，请写成if(str == ‘1’){}else if(str ==’2’ ){}else{}不要写成 if(str ==’1’ ){}else{} 命名最好不要简写，最终目标是，看见变量名就能知道这个变量是做什么用的，不要让别人猜，产生歧义。 遇见代码格式变化较大或者较多时，将原版代码格式化提交后，再讲自己代码提交，这样方便对比追溯。 不要使用反歧义的boolean。如： 用true表示未完成，false表示完成。 对于稍长的字符串，使用时如果不是自动生成，请复制后使用，不建议手打，容易出错。如： mabatis中mapper.xml和mapper.java对应的表名，空间名。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PreparedStatement]]></title>
    <url>%2F2019%2F12%2F28%2FPreparedStatement%2F</url>
    <content type="text"><![CDATA[PreparedStatement 是一个特殊的Statement对象，如果我们只是来查询或者更新数据的话，最好用PreparedStatement代替Statement，因为它有以下有点： 简化Statement中的操作 提高执行语句的性能 可读性和可维护性更好 安全性更好。 使用PreparedStatement能够预防SQL注入攻击，所谓SQL注入，指的是通过把SQL命令插入到Web表单提交或者输入域名或者页面请求的查询字符串，最终达到欺骗服务器，达到执行恶意SQL命令的目的。注入只对SQL语句的编译过程有破坏作用，而执行阶段只是把输入串作为数据处理，不再需要对SQL语句进行解析，因此也就避免了类似select * from user where name=’aa’ and password=’bb’ or 1=1的sql注入问题的发生。 Statement 和 PreparedStatement之间的关系和区别. 关系：PreparedStatement继承自Statement,都是接口 区别：PreparedStatement可以使用占位符，是预编译的，批处理比Statement效率高]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[隐藏（hide）和重写（override）和遮掩（obscure）遮蔽（shadow）和重载（overload）]]></title>
    <url>%2F2019%2F11%2F28%2F%E9%81%AE%E8%94%BDobscure%2F</url>
    <content type="text"><![CDATA[重写（override）一个实例方法可以overide在其超类中可以访问到的具有相同签名的所有方法，从而可以动态分派（dynamic dispatch），VM基于运行时类型来选择要调用的覆写方法。12345678class Base &#123; public void f() &#123; &#125;&#125;class Derived extends Base &#123; public void f() &#123; &#125; // overrides Base.f()&#125; 隐藏 hide一个域，静态方法，或成员类型可以分别被隐藏（hide）在其超类可以访问到的具有相同名字的所有域、静态方法或成员类型。hide几个成员将阻止其被继承。// 错误样例12345678class Base &#123; public static void f() &#123; &#125;&#125;class Derived extends Base &#123; private static void f() &#123; &#125; // hides Base.f()&#125; // 正确样例12345678910111213141516171819202122232425class Base &#123; static int a = 1; int b = 3; public static void f() &#123; System.out.println(&quot;Base&quot;); &#125;&#125;class Derived extends Base &#123; static int a = 2; int b = 4; public static void f() &#123; System.out.println(&quot;Derived&quot;); &#125; // hides Base.f()&#125;public class Hide &#123; public static void main(String[] args) &#123; Base.f(); Derived.f(); System.out.println(Base.a); System.out.println(Derived.a); System.out.println((new Base()).b); System.out.println((new Derived()).b); System.out.println(((Base) (new Derived())).b); &#125;&#125; 重载（overload）在某个类中的方法可以重载（overload）另一个方法，只要它们具有相同的名字和不同的签名。由调用所指定的重载方法是在编译期选定的。 遮蔽（shadow）一个变量、方法或类型可以分别遮蔽（shadow）在一个闭合的文本范围内的具有相同名字的所有变量、方法或类型。如果一个实体被遮蔽了，那么你用它的简单名是无法引用到它的；根据实体的不同，有时你根本就无法引用到它。1234567class WhoKnows &#123; static String sentence = &quot;I don&apos;t know.&quot;; public static void main(String[] args) &#123; String sentence = &quot;I know!&quot;; // shadows static field System.out.println(sentence); // prints local variable &#125;&#125; 编译器在选择在运行期被调用的方法时，所做的第一件事就是在肯定能找到该方法的范围内挑选。编译器将在包含具有恰当名字的方法的最小闭合范围内挑选，下例中就是ImportDuty类，它包含了从Object继承的方法toString。 导入的toString方法被继承的toString方法所遮蔽（shadow） 本身就属于某个范围的成员在该范围内与静态导入相比具有优先权。以下代码无法被编译通过123456789import static java.util.Arrays.toString;class ImportDuty &#123; public static void main(String[] args) &#123; printArgs(1, 2, 3, 4, 5); &#125; static void printArgs(Object... args) &#123; System.out.println(toString(args)); &#125;&#125; 遮掩（obscure）一个变量可以遮掩具有相同名字的一个类型，只要它们都在同一个范围内：如果这个名字被用于变量与类型都被许可的范围，那么它将引用到变量上。相似地，一个变量或一个类型可以遮掩一个包。遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式，这些名字空间包括：变量、包、方法或类型。12345678// 变量遮掩了类型public class Obscure &#123; static String System; // Obscures type java.lang.System public static void main(String[ ] args) &#123; // Next line won&apos;t compile: System refers to static field System.out.println(”hello, obscure world!“); &#125;&#125; 当一个变量和一个类型具有相同的名字，并且他们位于相同的作用域时，变量名具有优先权 JLS 6.5.2，变量将遮掩（obscure）类型名。相似地，变量名和类型名可以遮掩包名。1234567891011121314public class ShadowOfGray &#123; public static void main(String[] args) &#123; System.out.println(X.Y.Z); // 输出结果White &#125;&#125;class X &#123; static class Y &#123; static String Z = &quot;Black&quot;; &#125; static C Y = new C();&#125;class C &#123; String Z = &quot;White&quot;;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iterator和iterable]]></title>
    <url>%2F2019%2F10%2F28%2Fiterator%E5%92%8Citerable%2F</url>
    <content type="text"><![CDATA[迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。Iterator是java.util包下的接口:123456package java.util;public interface Iterator&#123; boolean hasNext(); Object next(); void remove();&#125; Iterable是java.lang下的接口:12345package java.lang;import java.util.Iterator;public interface Iterable&#123; Iterator iterator();&#125; 在jdk 1.5以后，引入了Iterable，使用foreach语句（增强型for循环）必须使用Iterable类。 Collection继承于Iterable而不是Iterator接口。Iterable的子类是Collection，Collection的子类是List，Set，这些是数据结构的类，用于存放数据。Iterator是定义迭代逻辑的类，让迭代逻辑和数据结构分离开来，这样的好处是可以在一种数据结构上实现多种迭代逻辑 每一次调用Iterable的Iterator()方法，都会返回一个从头开始的Iterator对象，各个Iterator对象之间不会相互干扰，保证了（多线程）可以同时对一个数据结构进行多个遍历。]]></content>
  </entry>
  <entry>
    <title><![CDATA[解析藏宝阁密文]]></title>
    <url>%2F2019%2F10%2F27%2F%E8%A7%A3%E6%9E%90%E8%97%8F%E5%AE%9D%E9%98%81%E5%AF%86%E6%96%87%2F</url>
    <content type="text"><![CDATA[以下内容仅作为技术讨论使用，务商业使用。 在查看梦幻藏宝阁的时，像了解下对于数据的展示，这种平台是如何操作，于是对网页数据进行了分析，以下是分析出数据的方法。 对于一些敏感数据，网站就需要对其进行混淆，增加爬虫的成本。 例如网页https://xyq.cbg.163.com/equip?s=212&amp;eid=201908132100113-212-AQYRMWM0DU8U&amp;o&amp;equip_refer=58 分析其返回的response,发现返回值并没有直接赋值上去。123456789101112131415161718&lt;tr&gt; &lt;th&gt;气血：&lt;/th&gt; &lt;td&gt;&lt;%= pet.blood %&gt;/&lt;%= pet.max_blood %&gt;&lt;/td&gt; &lt;th&gt;体质：&lt;/th&gt; &lt;td&gt;&lt;%= pet.soma %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;魔法：&lt;/th&gt; &lt;td&gt;&lt;%= pet.magic %&gt;/&lt;%= pet.max_magic %&gt;&lt;/td&gt; &lt;th&gt;法力：&lt;/th&gt; &lt;td&gt;&lt;%= pet.magic_powner %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;攻击：&lt;/th&gt; &lt;td&gt;&lt;%= pet.attack %&gt;&lt;/td&gt; &lt;th&gt;力量：&lt;/th&gt; &lt;td&gt;&lt;%= pet.strength %&gt;&lt;/td&gt; &lt;/tr&gt; 由pet对象来获取，则在网页中查找这个对象 1234&lt;% var pet = this.pet_attrs; var enhance_info = this.enhance_info || &#123;&#125;;%&gt; 继续查找pet_attrs12var pet_desc = parse_desc_info($(&quot;equip_desc_&quot; + el.getAttribute(&quot;data_equipid&quot;)).value);var pet_attrs = get_pet_attrs_info(pet_desc, true); 这串代码中，根据equip_desc_查到到了这个网页的主要信息内容。123&lt;textarea id=&quot;equip_desc_value&quot; style=&quot;display:none&quot;&gt;超级神兔;102273;169;3269;1920;2425;964;280;100;300;189;1092;189;189;0;956;3269;1920;65432;1;1600;1600;5500;3500;1400;1400;1300;425|404|416|405|422;0;1;0;2;0;0;([&quot;tmp_lingxing&quot;:0,&quot;core_close&quot;:0,&quot;lastchecksubzz&quot;:0,&quot;summon_core&quot;:([901:(&#123;5,0,([]),&#125;),924:(&#123;5,0,([]),&#125;),932:(&#123;5,0,([]),&#125;),]),&quot;left_qlxl&quot;:7,&quot;weaken&quot;:0,&quot;growthMax&quot;:1236,&quot;iJjFeedCd&quot;:0,&quot;summon_equip4_type&quot;:0,&quot;carrygradezz&quot;:0,&quot;MP_MAX&quot;:3050,&quot;sjg&quot;:0,&quot;summon_color&quot;:0,&quot;csavezz&quot;:&quot;1600|1600|1400|1400|5500|3500&quot;,&quot;MS_MAX&quot;:1800,&quot;jj_extra_add&quot;:0,&quot;iRealColor&quot;:0,&quot;SPD_MAX&quot;:1550,&quot;DEF_MAX&quot;:1550,&quot;summon_equip4_desc&quot;:&quot;&quot;,&quot;HP_MAX&quot;:5500,&quot;jinjie&quot;:([&quot;core&quot;:([]),&quot;cnt&quot;:0,&quot;lx&quot;:0,]),&quot;ATK_MAX&quot;:1550,&quot;strengthen&quot;:0,])&lt;/textarea&gt; 过程有些顺利 接下来在解析角色时，发现equip_desc_value的value值并没有直接体现出来。如：https://xyq.cbg.163.com/equip?s=579&amp;eid=201907212200113-579-5ZF1WK0H3GFP&amp;equip_refer=26&amp;view_loc=reco_left1&lt;textarea id=&quot;equip_desc_value&quot; style=&quot;display:none&quot;&gt;&lt;textarea id=&quot;equip_desc_value&quot; style=&quot;display:none&quot;&gt;@VB38(因内容太多，此处省略)DAxOSJ9@&lt;/textarea&gt; 继续追本溯源查找equip_desc_value，查找到以下代码1var role_info = js_eval(lpc_2_js(get_equip_desc(&apos;equip_desc_value&apos;))); 通过打断点的方式发现get_equip_desc方法为解析加密的内容的核心方法。（lpc_2_js是将字符串转为对象字符串的方法，并不是核心方法）继续往下查找get_equip_desc方法123function get_equip_desc(elemId) &#123; return decode_desc($(elemId).value);&#125; 好吧，继续查看decode_desc方法,看到这种代码，终于进入主题了。1234567891011121314151617181920212223242526272829303132333435!function(_0xcbc80b) &#123; _0xcbc80b[&apos;\x64\x65\x63\x6f\x64\x65\x5f\x64\x65\x73\x63&apos;] = function g(_0x1c0cdf) &#123; if (_0x1c0cdf = _0x1c0cdf[&apos;\x72\x65\x70\x6c\x61\x63\x65&apos;](/^\s+|\s+$/g, &apos;&apos;), !/^@[\s\S]*@$/[_0x3a8e(&apos;0x0&apos;)](_0x1c0cdf)) return _0x1c0cdf; var _0x36ab38 = (/\b_k=([^;]*)/[&apos;\x65\x78\x65\x63&apos;](document[&apos;\x63\x6f\x6f\x6b\x69\x65&apos;]) || [])[0x1] || &apos;&apos;; if (_0x1c0cdf = _0x1c0cdf[&apos;\x72\x65\x70\x6c\x61\x63\x65&apos;](/^@|@$/g, &apos;&apos;), /^[^@]+@[\s\S]+/[&apos;\x74\x65\x73\x74&apos;](_0x1c0cdf)) &#123; var _0x33c80e = _0x1c0cdf[&apos;\x69\x6e\x64\x65\x78\x4f\x66&apos;](&apos;\x40&apos;); _0x36ab38 = _0x1c0cdf[_0x3a8e(&apos;0x1&apos;)](0x0, _0x33c80e), _0x1c0cdf = _0x1c0cdf[&apos;\x73\x75\x62\x73\x74\x72\x69\x6e\x67&apos;](_0x33c80e + 0x1); &#125; var _0x1b3f48 = function s(_0x1c0cdf) &#123; try &#123; return _0xcbc80b[&apos;\x65\x76\x61\x6c&apos;](&apos;\x28&apos; + _0x1c0cdf + &apos;\x29&apos;); &#125; catch (_0x40b9c3) &#123; return null; &#125; &#125;(_0x1c0cdf = _0xcbc80b[_0x3a8e(&apos;0x2&apos;)](_0x1c0cdf)); _0x1b3f48 &amp;&amp; &apos;\x6f\x62\x6a\x65\x63\x74&apos; == typeof _0x1b3f48 &amp;&amp; _0x1b3f48[&apos;\x64&apos;] &amp;&amp; (_0x1b3f48 = _0x1b3f48[&apos;\x64&apos;]); for (var _0x20b9fa = [], _0x10503c = 0x0, _0x1a524d = 0x0; _0x1a524d &lt; _0x1b3f48[&apos;\x6c\x65\x6e\x67\x74\x68&apos;]; _0x1a524d++) &#123; var _0x3641ed = _0x1b3f48[&apos;\x63\x68\x61\x72\x43\x6f\x64\x65\x41\x74&apos;](_0x1a524d) , _0x341952 = _0x36ab38[_0x3a8e(&apos;0x3&apos;)](_0x10503c % _0x36ab38[&apos;\x6c\x65\x6e\x67\x74\x68&apos;]); _0x10503c += 0x1, _0x3641ed = 0x1 * _0x3641ed ^ _0x341952, _0x20b9fa[_0x3a8e(&apos;0x4&apos;)](_0x3641ed[&apos;\x74\x6f\x53\x74\x72\x69\x6e\x67&apos;](0x2)); &#125; return function d(_0x1c0cdf) &#123; for (var _0x36ab38 = [], _0x33c80e = 0x0; _0x33c80e &lt; _0x1c0cdf[&apos;\x6c\x65\x6e\x67\x74\x68&apos;]; _0x33c80e++) _0x36ab38[&apos;\x70\x75\x73\x68&apos;](_0xcbc80b[&apos;\x53\x74\x72\x69\x6e\x67&apos;][&apos;\x66\x72\x6f\x6d\x43\x68\x61\x72\x43\x6f\x64\x65&apos;](_0xcbc80b[&apos;\x70\x61\x72\x73\x65\x49\x6e\x74&apos;](_0x1c0cdf[_0x33c80e], 0x2))); return _0x36ab38[&apos;\x6a\x6f\x69\x6e&apos;](&apos;&apos;); &#125;(_0x20b9fa); &#125; ; &#125;(window); 对此先将方法去混淆.刚开始看到 _0x1c0cdf[_0x3a8e(‘0x1’)](0x0, _0x33c80e) 这种写法我还懵圈了老半天，这是种什么写法。后来在去混淆的过程中发现 _0x3a8e(‘0x1’) 的值是substring，这不就是方法名吗，然后意识到，这不就是js调用方法的另一种写法吗 ，只是很久不用这种写法第一眼没有认出来。1234567891011121314151617181920212223242526272829303132333435function decode_desc(ciphertext) &#123; if (ciphertext = ciphertext.replace(/^\s+|\s+$/g, &apos;&apos;), !/^@[\s\S]*@$/.test(ciphertext)) return ciphertext; var _0x36ab38 = &quot;&quot;;//(/\b_k=([^;]*)/.exec(document.cookie) || [])[0x1] || &apos;&apos;; if (ciphertext = ciphertext.replace(/^@|@$/g, &apos;&apos;), /^[^@]+@[\s\S]+/.test(ciphertext)) &#123; var num = ciphertext.indexOf(&apos;@&apos;); _0x36ab38 = ciphertext.substring(0, num), ciphertext = ciphertext.substring(num + 0x1); &#125; debugger; var _0x1b3f48 = function s(ciphertext) &#123; try &#123; return window.eval(&apos;(&apos; + ciphertext + &apos;)&apos;);// &#125; catch (_0x40b9c3) &#123; return null; &#125; &#125;(ciphertext = window.atob(ciphertext));//解码 _0x1b3f48 &amp;&amp; &apos;object&apos; == typeof _0x1b3f48 &amp;&amp; _0x1b3f48[&apos;d&apos;] &amp;&amp; (_0x1b3f48 = _0x1b3f48[&apos;d&apos;]);//从对象&#123;&apos;d&apos;:&apos;xxx&apos;&#125; 取到xxx var str=_0x1b3f48; //numList 是二进制数字的集合 for (var numList = [], j = 0, i =0; i &lt; str.length; i++) &#123; var charCode = str.charCodeAt(i) , _0x341952 = _0x36ab38.charCodeAt(j % _0x36ab38.length);//_0x36ab38 是一个短的字符串 如 QOGBzhZ8hvVKgka8 j ++, charCode = 0x1 * charCode ^ _0x341952, numList.push(charCode.toString(2)); &#125; return function d(ciphertext) &#123; for (var arr = [], i = 0; i &lt; ciphertext.length; i++) arr.push(window.String.fromCharCode(window.parseInt(ciphertext[i], 2))); return arr.join(&apos;&apos;); &#125;(numList); &#125; 至此提供一个完整版js解密代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function decodeObject()&#123;var role_info = js_eval(lpc_2_js(decode_desc( &quot;@QOGBzhZ8hvVKgka8@eyJkIjogInlcdTAwMTRlMVx1MDAxMlxyNElcdTAwMDFUbGM8NkhcdTAwMTRzJlx1MDAwNSdcdTAwMWJcdTAwMWIua1x1MDAwM1x1MDAxZmdpXVtNXHUwMDFhOFxmJjFcdTAwMTJKYFxmXkZufF9HQ1FcdTAwMTk/XHUwMDE4XHUwMDBmXHUwMDFiXHUwMDEweFx1MDAwMllAbnJLSTV5XHUwMDBlJlx1MDAwNi5cdTAwMTYmP084XHUwMDE5PyVcdTAwMTNJW1x0fW1cdTAwMDYhXHUwMDEyODVRXHUwMDA2XHUwMDAyXHUwMDAyJFx1MDAxM1xuXHJcdTAwMWFreHZ3Vkozdlx1MDAxZFx1MDAwMiVcdTAwMDVcdTAwMTJcdTAwMDZDXHUwMDAyYWNlK1x1MDAxZFx1MDAwNzVcXFx1MDAwNlx1MDAxMyU4OFx1MDAxOFx1MDAwME5zdXV2TFxcdlx1MDAxYVx1MDAwMTs3LDgqXHJUc3V2dEpEeEpcclx1MDAxOFwiXHUwMDE0XHUwMDBiXHUwMDBlXHUwMDE3XT1tfXJWSjNsXHUwMDA3XHUwMDAyNycqXG5cdTAwMDZ8NClcdTAwMTgjXHUwMDE2XHUwMDA0eFx1MDAwMlxcRGJnRVxiL1k8KmV4WFx1NWE1OVx1NGUwYVxmXFxCdGdFXHUwMDAyMls5ICguWFJrXHJEVD9cdTAwMDZcdTAwMTdJW1x1MDAwZmV9a2AuKVx1MDAwNVEpXHUwMDFhOlx1MDAxYlxiXHUwMDAyXHUwMDBmTHN1d25YXHUwMDAxXHRTXHUwMDAxJjlcIlx0XHUwMDFmQ1x1MDAwMmJcdTAwN2ZrYFx1MDAxMyE5V1x1MDAwNlRsel5HQ30pP1xyNVhSalx1MDAxNEpcdTAwMWZcdTAwMTMzXHUwMDE3XHUwMDFmMlM4e2V4SkR4UTpcdTAwMTMlXHUwMDE0Jlx1MDAwN1xyXHUwMDFha35ydlZKPFlcdTAwMWFcdTAwMWJcdCdcdTAwMDJcdTAwMWRcdTAwMDRUc3V3blhcdTAwMDFcYllcdTAwMGJcdTAwMTN0cVVHQ1FcdTAwMTJcYlx1MDAxMy1cdTAwMGVcdDZ5XHUwMDA1XHUwMDE5IyVcdTAwMTNJW1xifW0uXHUwMDA3XHUwMDAyXHUwMDE4LmtcdTAwMDNcdTAwMWZjaV1bTVx1MDAxYThcdTAwMWNcIjVcdFx1MDAwMzNcdTAwMWFSRnppXHUwMDBlL1x1MDAwNF5cdTAwMGVcdTAwMGUrLlhSb1xiWVp0OVx1MDAwMlx1MDAwNVx1MDAxNVx1MDAxYWtcdTAwN2ZrYFx1MDAxOVx1MDAwNzdVXHUwMDFkKTFcIlx1MDAwM0lbXGJ9bVwiLFx1MDAxZlx1MDAxYT1BSkxie0tJXGJ9Iz0mLFx1MDAwZVx1MDAxYSNcdTAwMWFSRnppXHUwMDBlL1x1MDAwNEBcdTAwMGVcdTAwMGUrLlhSb1x1MDAwZVFadFwiJVx1MDAwZVx1MDAwMEslXHUwMDFjLCtJSmBcYkRUP1x1MDAwZVx1MDAxZlx1MDAxYlx1MDAxNWs6JnZgQFh2XHUwMDFhXHRcdTAwMTIyXHUwMDFiXGJcdTAwMDJcdTAwMGZMc3V3blhcbjNcXEpMZmdFXHUwMDAyLko2XHUwMDAwISRcdTAwMWZcdTAwMWF4XHUwMDAyWFp0M1x1MDAwZVxuXHUwMDBmQSRtfXJWSjRXXHUwMDFhXHUwMDFiNyc4XHUwMDAzXHUwMDBlSlwiKmV4SkR4WydcdTAwMDQxaV1JXHU3MDJkXHU3YmQ2XHU5YTg5XHU2MjA0ZW5YXHUwMDE4P0xKTH4wXHUwMDFhQk1cdTAwMWE+PS5cdTAwMWRcYlx0OV1KTGRnRVx1MDAwMiVdXCIsZXhKRHhwXHUwMDFkXHUwMDExM1x1MDAwM1xiXHUwMDE5XHUwMDEyXXN1b1x1MDAxOSdBdlx1MDAxYVx1MDAwMSYkXCJcdTAwMDNcdTAwMGVDXHUwMDAyZ3Z2blhcdTAwMDFcdTAwMTdZXHUwMDFhXHUwMDA0L2ldW01cdTAwMWE4XHUwMDBiJi9cdTAwMWJcdTAwMGY/ZylcdTAwMWE6aV1aUVxyaWNlXHUwMDA3XHUwMDAyKSxMSkx+XHUwMDEwOkJNXHUwMDFhOFx1MDAxYig2XHUwMDFiXHUwMDA0XHUwMDE3WVx1MDAwZjI3JjhcblxyVHN1cnJDRHhROFx1MDAxNT0/N1xuXHUwMDA2XXN1d25YXHUwMDA0M1ZcdTAwMGZcdTAwMTQ3JEVRSWNcZmZrYFx1MDAxMyU7Slx1MDAxYVx1MDAwZmRpXVtNXHUwMDFhOFx1MDAwMiY6P1x1MDAxMCpMWlRseVdHQ1FcdTAwMTJcYlx1MDAwNS1cdTAwMDIpN1dcdTAwMWRcdTAwMThcImldW01cdTAwMWE+PS5cdTAwMWRcdTAwMWVccilbSkxke1NTTVx1MDAxYSE9KDIxXHIqTEpMflx1MDAxMDpCTVx1MDAxYThcdTAwMWMkKjVcdTAwMGU8XVx1MDAxYVRse0tJXGJ1MChcdTAwMDMnXHUwMDFjN1x1MDAxYlRcdTAwMDRUbFx1MDA3ZlVfTVx1MDAxYThcZlx1MDAwMFx1MDAwMFx1MDAxNVxmI3lcdTAwMDVcdTAwMTkjJVx1MDAxM0lbXGJ9bVx1MDAwNi5cdTAwMTY6M1xcXHJcdTAwMDR0cU8wPFx1MDAxMX1tLlx1MDAxMVx1MDAwZVx1MDAxYVx1MDAwNXlcdTAwMDRcdTAwMWF0cVZfUVx1MDAxNHNcbj8yMFx1MDAxZlx1MDAxOFlcdTAwMWJcdTAwMTN0cVZbUVxiYVx1MDA3ZndySlh2XHUwMDFhXHUwMDBlXHUwMDE3NCpcYklbXHUwMDEwXG5cdTAwMTJublhcdTAwMDFcdTAwMTJISkxnfV9fTVx1MDAxYThcdTAwMTUvN1x1MDAxYlx1MDAwNlx1MDAwMFBcdTAwMDFUbHpLSVxiez49XHUwMDE4XHUwMDAzXHUwMDE2XHUwMDA0eFx1MDAwMllBZ2dFXHUwMDAyMlU4Oy8xXHUwMDExXHUwMDAxeFx1MDAwMlhadFwiJVx1MDAwZVx1MDAwMEslXHUwMDFjLCtISmBcYkRUP1xmXGJcdTAwMDRcdTAwMDVWNDw0YEBZalxyXlp0Klx1MDAwYlx1MDAwNz5LOiYrLlx0SmBcdTAwMTAzVGdyUUlbXHR9bXR2QlhuXHUwMDFhUkd6aVVaV1x1MDAxYWt7cm5YWWpcdTAwMGVKTGd4V0dDXG5gfmV4SFh2XHUwMDFhWUZjaV1aUlxifW12dEpKYFx0RFRnfFNJW1x0fW11c0pKYFx0XVp0eldcXENcdTAwMDJgfHduWFpqXHUwMDAxSkxlfUtJUFx1MDAwZmFtfXNWSmtcYlBUbHpUW01cdTAwMWFkfXdxSEpgXHREVGd7XklbXHRiXHUwMDdma2BIWWhcdTAwMWFSRGZnRVpUXHUwMDAwc3V0blhZbFx1MDAwZkpMZ2dFXlNcYmJ+ZXhLRHhcdFlGdHFWWFFcdTAwMTRzenVyS154XHUwMDAyWVp0el5SQ1x1MDAwMmBjZXNDX3hcdTAwMDJZWnR4U1NRXG5zdXZuWFlrXHRKTGdnRVpYXHUwMDAwc3V2blhZbFx1MDAwMUpMZ2dFWVFcbnN1dHdWSmhcYllUbH5XR0NcdGZ2ZXhLRFx1MDAwN1x1MDAxMURUP3ghXHUwMDA3XHUwMDE4dCdtfXJWSjN0XHJcdTAwMTckJSRcblx1MDAxMlBzdXJ3SFtiXHUwMDBiRFQ8XCJcdTAwMWVcdTAwMWVcdTAwMDBWc3V3blhcdTAwMWQpXVx1MDAxYVx1MDAxOCMmRVFVXG5ifHZ3Tlxcdlx1MDAxYVx1MDAwMTMuO1x1MDAxMzhcblFibX11Vkoza1x1MDAxOFx1MDAxM1x0XG5cdTAwMGJcdTAwMDdDXHUwMDAyZntwblhcdTAwMDFcbldcdTAwMDFcdTAwMThcImldW01cdTAwMWE4XHUwMDFjMi87XHUwMDA1NU1cdTAwMDZcdTAwMDJ0cV9HQ1FcdTAwMTk/XHUwMDE4XHUwMDA3XHUwMDFjXHUwMDBleFx1MDAwMllAbnJLSVxiXHUwMDdmIy4jJ1hSa1xuUVp0XCIlXG5cdTAwMDVWNDw0YEBYdlx1MDAxYVx1MDAwN1x1MDAwM1wiL1xiXHUwMDA0XHUwMDEzZz0qMSdcdTAwMTZKYFxiRFQ/XHUwMDA2XHUwMDE3NCxZKW19dU5adlx1MDAxYVx1MDAwMTI5LzgqXHJUc3Vwd01EeFEpXHUwMDAyXCJcdTAwMTQmXHUwMDA3XHJcdTAwMWFreHRyVkoza1x0XHUwMDAwPyVcdTAwMDBJW1xifW0uXHUwMDA3XHUwMDAyXHUwMDE4LmtcdTAwMDNcdTAwMWZkaV1bTVx1MDAxYTInJixcdTAwMWRccilbXHUwMDAwVGxjXHUwMDFjXHUwMDE2SFx1MDAxNHMsKC9cdTAwMTdcdTAwMWRcdTAwMDVWXHRcdTAwMWIzaV1bTVx1MDAxYThcdTAwMDImOj9cdTAwMTAqTFtUbHlXR0NRXHUwMDEzKiYxXHUwMDBlOzFRXFxUbHtLSVx1MDAxMk08XHUwMDEwXCI6XG5KYFx1MDAwMURUXCIkXHUwMDEzXG5ccmc5IDUxXHUwMDFmSmBcYkRUP1x1MDAwNlx1MDAwNlx1MDAxMyRAITt2YEBaalx1MDAxNEpcdTAwMWZcdTAwMDM7XCJcdTAwMTNcdTAwMTFcdTAwMWFrenVxSFpvXHRYWnQ4XHUwMDBmXHUwMDBlXHUwMDBmSThcdTAwMTA+J1x1MDAxNlx1MDAwNDVPSkx0aUtJXHUwMDA1WSUuKSUlXHUwMDBlP1lcdTAwMWNUbHlfUlJcdTAwMTRzPDAtXGJcZlx1MDAwNUtcdTAwMGJcdTAwMTkkLkVRUVx1MDAxNHNcIigwXHUwMDFmNztMXHUwMDFjXHUwMDA0dHFPMENZJTs1MVhSckNALXRcIlx1MDAwM1x1MDAxM0NcdTAwMDJgfmtgXHUwMDE2XHUwMDFleFx1MDAwMlhaXHUwMDBiYktDOlx1MDAxYTgrP2BAXnZcdTAwMWFcdTAwMDRcdTAwMDB0cVdHPFx1MDAxMX1nXHUwMDFjYFx1MDAxM1xmXCJcdTAwMWFSQnppXHUwMDBiXHUwMDFkQ1x1MDAwMmFjXHUwMDFha1ZAXHUwMDAxXHUwMDFhXHUwMDAxXHUwMDEyLmldWU1cdTAwMWE9OWV4SkRcdTAwMDdcdTAwMTFEXlxyaVx1MDAwZVx1MDAwZlx1MDAxOVx1MDAxYWt+dW5YXHUwMDA0LFx1MDAxYVJGelx1MDAxNk5HSWNzJiM6WFJrXHUwMDE0Slx1MDAxYSBpXVtNZXhjb1x1MDAxOVhcdTAwMDE+QEpMZWdFXHUwMDA3XHUwMDE3XHUwMDFha1x1MDA3ZmtcdTAwMWZTRHJjSlx1MDAxZjIzRVFQXGJ9bSs0WFJqXHUwMDE0NV96YzxJXGJcXCltfXdWSjZOSkxmZzpCTVx1MDAxMFxubS4mXHUwMDAySmBcdTAwMDBEVDo9RVFRXHUwMDE0XGZma2ohSjNcXFx1MDAxMFRscktJXHJOc3V3bidBdlx1MDAxMDNUPy9cdTAwMWZJW1x1MDAwZn1tKzRYUmpcdTAwMTQ1X3pjPElcYlxcKW19c0lEeFRcdTAwMWVUbHxSXFxNZXhjb1x1MDAxOVhcdTAwMDE+QEpMZ1x1MDA3ZktJXHJOc3VzcE5EXHUwMDA3XHUwMDExRFx1MDAwYlx1MDA3Zmc6Qk1cdTAwMWE4KyUrXHUwMDFlNz5dXHUwMDFiXHUwMDE1dHFPXHUwMDEwXHUwMDFjXHUwMDExfW1cdTAwMDYuXHUwMDE2Oy9VXHUwMDA1XHUwMDE5OGldQ1x1MDAxYVx1MDAxMFxubS5cdTAwMTBcdTAwMWZcdTAwMWJcdTAwMDVZXHUwMDA0XHUwMDFhdHFVXU1cdTAwMWE9LjQ2XHUwMDE5XHUwMDAwP1tcdTAwMDNcdTAwMDUjKVx1MDAxZFx1MDAxMUNcdTAwMDJjXHUwMDdmdntWSjN1XHUwMDE4VGx+UEdDVDguKTFcdTAwMTJcdTAwMDcvXHUwMDFhUkZ6aVx1MDAwM1x1MDAwNFx1MDAwNVx1MDAxYWt+dnZORHhZXHUwMDFjXHUwMDAyXHQ5XHUwMDA2XHUwMDFmXHUwMDA0XHUwMDFha1x1MDA3ZmtgXHRcdTAwMWQ3VVx1MDAwN1x1MDAxOFx0KFxiXHUwMDA3XHUwMDBlSnN1d25YXHUwMDAxXHUwMDFlXVx1MDAwZSlcdTAwMTcnXHUwMDBiSVtcZmVjZTBcdTAwMGZcdTAwMTEzXFxcdFx1MDAxOHRxV0dDUVx1MDAxYy4gXHUwMDA2XHUwMDFmXHUwMDBlXHUwMDA1WVx1MDAwNFx1MDAxYXRxVFpNXHUwMDFhOFx1MDAwMiYlJVx0NlRKTGdcdTAwN2ZLSVxifDQ3XHUwMDE4XHUwMDAzXHUwMDE2XHUwMDA0eFx1MDAwMlxcR3ppXHUwMDE0XHUwMDFlXGZVPiFcdTAwMTgnXHUwMDBiXHUwMDFkM0hcXCkyLlx1MDAxNFxiQ1x1MDAwMnNta2BcdTAwMTMpLkw3MHRxX0dDSyRcIiotXHUwMDE0NzlXXHUwMDFhXHUwMDEzdHFPMDxcdTAwMTF9bS0rXHUwMDE0XHUwMDAyM11KTH5cdTAwMTBFXGJcdTAwMGVKNG19aiE1c1x1MDAxNEpcdTAwMTU4P0VRUVx1MDAxNHMjP2BAWHZlQVp0XHUwMDAzNzQseVx0bX13T1hqXHUwMDE0Slx1MDAxMSQkXHUwMDEwSVtcdGF4cm5YXHUwMDBiKVlcdTAwMWVcdTAwMTMsMUVRQ1x0Y353PktablxuXHUwMDE0R2RcdTAwN2ZUXHUwMDE3UFx0ZXs7cUJdakRaRmVcdTAwN2ZFR0NfIyAwNlx1MDAxMiU7QEpMZ3tUW01cdTAwMWE4XHUwMDFiPjJcdTAwMWZKYFx0WERme1NHQ1FcdTAwMTYqKStcdTAwMGZcdTAwMWJ4XHUwMDAyWFp0KFx1MDAwNlx1MDAxOVx1MDAxM0E2PSYmXHUwMDFmXHUwMDEyIFx1MDAxYVJGemlcdTAwMGUqXHUwMDE1TFx1MDAwZS4rLlhSaFx1MDAwMURUNz9cdTAwMTNJW1x0Y353blhcdTAwMDUqXHUwMDFhUkRmeFNHQ0s7KGV4SkR4azgyXHRcdTAwMDYmM0NcdTAwMDJgenJyVkojTVx0XHUwMDE4LlwiXHUwMDA2XHUwMDA0Q1x1MDAwMmFjZSspXHUwMDFjKGdcdFx1MDAxYTppXVpZXHUwMDE0cyZcbjIlXHUwMDA1O0BKTGN8S0lcYnAhbX1zTF12XHUwMDFhXHUwMDAxJSYuOFxuXHJUc3V0cVZKM3pcdFx1MDAxOTQqXGJJW1x0fW0mLlx1MDAxNjcpU1x1MDAwMVx1MDAxYTo4RVFJY3N8d3dYUmtcdTAwMTRKQmd8RVFQXHUwMDE0XGZma2BcdFx1MDAxOD9cdTAwMWFSR2RcdTAwN2ZUR0NRXHUwMDEyIDVcdTAwMWRcdTAwMWJcdTAwMDQ2XHUwMDFhUkRiZ0VcdTAwMDIxVzghM2BAWW9cdTAwMTRKXHUwMDA3PypcdFx1MDAwMVxiVj06ZXhKRHhRIFx1MDAwNlx0Jlx1MDAwNlx1MDAxM0NcdTAwMDJgeXJuWFx1MDAwMVxiXVx0XHUwMDFhXHUwMDE1JFx1MDAwYlx1MDAwNFx1MDAxM1x1MDAxYWtcdTAwN2ZrYFx1MDAxMy8oWVxmXHUwMDEzdHFUR0NbPj1cIlx1MDAxZFx1MDAxOVx1MDAwNDVLXHJUbHtLSVxyXTc7XHUwMDE4M1x1MDAxNlx1MDAxMDZcdTAwMWFSQXppXHUwMDBlL1x1MDAwZVxcXHUwMDBlXHUwMDBlKy5YUmlcdTAwMGZEVFwiJlx1MDAxNzRcclE/KD8rXHUwMDE0XHUwMDBmeFx1MDAwMlhadCdcdTAwMGVcclx1MDAwNFx1MDAxYWt2dXZNRHh5PD1cdFx1MDAwNiYzQ1x1MDAwMmB6cnJWSjJISkxlc1JbTVx1MDAxYVwiOiovXHUwMDE1XHUwMDA2XHUwMDA1XVx1MDAxOVx1MDAwMz87UzRcdTAwMTVBISpleEpEeFxcXHJcdTAwMTB0cVZZVVxufW1cdTAwMDNcdTAwMDc8N1x1MDAxN3kwVGx6Ul5RXHUwMDE0c1x1MDAwMlx1MDAxNFx1MDAxZDcpXHUwMDAyXHUwMDFhUkdue1dHQ3VcdTAwMDFcdTAwMTBcblx1MDAwM1wiSmBcdTAwMGJYQ2ZnRVx1MDAwMVx1MDAwYmc0NzMwXHUwMDFiNztcXFxmVGx7S0lcYnI7XHRcIidcdTAwMWUrPlx1MDAxYVJGelx1MDAxNk5HSWNzJlx1MDAxNSdcdDc7VFx1MDAwNFRsel9HQ1QwPDMhXHUwMDEyXHI5U1x1MDAxYlx1MDAwMzQxXHUwMDFkSVtcbmF+fm5YXHUwMDAxXHUwMDE3SEpMYn5LSVxyUTAhNCpcdTAwMTVcdTAwMWR4XHUwMDAyWFp0L1xiXHUwMDBmQ1x1MDAwMmBcdTAwN2Z1dFZKO0xcdTAwMWMpJCpcdTAwMTNcdTAwMGVDXHUwMDAyYWNlMVx1MDAwZlx1MDAwNTdXXHUwMDA2KTUkXHUwMDBiXHUwMDA0XHUwMDEzXHUwMDFha1x1MDA3ZmtgXHUwMDEzLD9eNzc6J0VRU1x1MDAwZn1tNTdcdTAwMDNcdTAwMDE+WVx1MDAwNlRse0tJXGJ1MChcdTAwMDMnXHUwMDFjNztUXHUwMDA0VGx5UEdDUVx1MDAxYy4gXHUwMDFkXHUwMDFiXHUwMDA0Nlx1MDAxYVJHZWdFXHUwMDAyJV0pXHUwMDEwXHUwMDA2Llx1MDAxNkpgXHUwMDBiWVp0OFx1MDAxMlx1MDAwNlxmVz9cdTAwMTBcIjNcdTAwMGZcdTAwMDEqXGY3XHUwMDEyMzhcdTAwMDRJW1x1MDAxYXNjZSs7XHUwMDFjLmcuVGx5S0lcdTAwMTJNPFwiKCwlXHUwMDBiNUpcclRsYzw2SFx1MDAxNHMlLixcdTAwMTBcdTAwMDE/XHUwMDFhUl5ccmlcdTAwMDRcdTAwMDRcdTAwMTNdc3VvXHUwMDE5J0F2XHUwMDFhXHUwMDBiXHUwMDE4XCJpXVtNXHUwMDFhPTdleEpEXHUwMDA3XHUwMDExRFRcdTAwMWVcdTAwMWI4JiBgc3Vyd0pYdlx1MDAxYVx1MDAwZlx1MDAwNDk8RVFQXHRnfmtgXHUwMDE5XHUwMDFiO05cclxmLGldSVBcdGNcdTAwN2Y7c0tcXGpEWUJnfVx1MDAxYlpRXG5nM3NyQ10mXHRfRG5pS0lcdTAwMDZKPjgzKjdcdFwiXHUwMDFhUkdnc1NHQ1FcdTAwMDU2NydYUmtcYlpGZHhLSVxiXHUwMDdmNCEuN1x0SmBcYkRUNSpcdTAwMTVcdTAwMTlcdTAwMThfIy4jJ1x1MDAwMFx1MDAxMnhcdTAwMDJYWnRcIiZcdTAwMWZcdTAwMTVnMCMrYEBaalx1MDAxNEpcdTAwMTdcIj9FUVBcdGNcdTAwN2ZrYFx1MDAxN1x1MDAxOHhcdTAwMDJZQWRzS0lcdTAwMTJSNm19clZKXHRoLClcdTAwMWJcbj9JW1x0ZHp3blhcdTAwMTEvWVx1MDAwNlx1MDAwZT8qXGJJW1xifW0uXHUwMDExXHUwMDBlXHUwMDFhXHUwMDA1WVx1MDAwNFx1MDAxYXRxVlNNXHUwMDFhOFx1MDAwMjdcdTAwMWRcdTAwMTdcdFwiXHUwMDFhUkJjZ0VcdTAwMDIpSHN1dXJIRHhRO1x1MDAwNjNcdTAwMTRcdTAwMDZcdTAwMDdcclx1MDAxYWt9dW5YXHUwMDAxXHUwMDE4WVx1MDAwN1x1MDAxNDckRVFQXHUwMDE0cy4rLiVcdTAwMWIxUVx1MDAwNFx1MDAxYSVpXUM6XHUwMDFhZXx3YEBZdlx1MDAxYVtEYGldWk1cdTAwMWFkXHUwMDdmdWBAWXZcdTAwMWFbRmBpXVpNZXhjZTFcblxyeFx1MDAwMllCZ31LSVxiez49XHUwMDE4I1x1MDAxNlx1MDAwNHhcdTAwMDJaT3ppXHUwMDBlO1x1MDAwZVE/O2V4SkR4SVx1MDAwMVx1MDAxNzghXHUwMDBlXHUwMDA1XHJNc3V3blhcdTAwMDFcdTAwMTJIN1x1MDAxYjczRVFTXGJjY2UrKFxyO1QrXHUwMDE5OiRcdTAwMTVJW1xifW0uXHUwMDA1XGJcdD5dSkxmZ0VcYlx1MDAwZUo0XHUwMDEwJC5cdTAwMTVcdTAwMWI/XHUwMDFhUkZ6aVx1MDAwYlx1MDAwZVx1MDAwN0xcdTAwMGU+KzpcdTAwMTZKYFx1MDAwZkRUP1x1MDAwZlxiXHUwMDBmPnk9I2V4SFp2XHUwMDFhXHUwMDFjXHUwMDFiJlx1MDAxNFx1MDAwYlx1MDAwMlx1MDAwZl8pJiklWFJqXHUwMDE0Slx1MDAxYT8tXHUwMDAySVtcdGF7cnJWSlx1MDAxYmwjKVx1MDAxYlxuP0lbXHRkenduWFx1MDAwMCpcdTAwMWFSQmZyUkdDSyRcIiotXHUwMDE0Nz9JXHUwMDFkXHUwMDFmJlx1MDA3ZjhcdTAwMWZcdTAwMThING19clZKPl1cdTAwMGVUbHpWX1FcdTAwMTRzXHUwMDBiXHUwMDAyXHUwMDA0JSVcdTAwMWJgSkxnflJbTVx1MDAxYVx1MDAxY1x1MDAxY1x1MDAxOFx1MDAwZjsweFx1MDAwMllOZntLSSxoXHUwMDBlXHUwMDAyXHUwMDA2XHUwMDFhWFJpXGJdRnppXHJcdTAwMDE+XSk7NSMlXHQ+XFxKTGZnRVx1MDAwMitSXHUwMDE3KlwiJjlcZnhcdTAwMDJYWlx1MDAwYmJLXHUwMDE2SFx1MDAxNHMmXG4jXHUwMDAyLVwiSFx1MDAxY0J0cVVbTVx1MDAxYVwiJ1wiLFx1MDAwYlx1MDAwMVx1MDAwNUhcdTAwMDdcdTAwMDV0cU9cdTAwMTBRXHUwMDE0YWM6a1ZKXHUwMDFiVFx1MDAwNDMnPlx1MDAwZVx1MDAxYkNcdTAwMDJ5XHUwMDE0dnhSM3hRPFx1MDAwZiYuRVFTXHJgeGtgXHUwMDE5LD9LXHUwMDBiVGxpRFx1MDAxOVx1N2IyOFx1N2U5ZnF4d2JaSyhcdTliNmNcdTZjYmRWfXxXS1x1OTY1M1x1NWY5OXFkdHtZXHUwMDFhXHU4MDRhXHU0ZTdkXHU1ZWNlVmV5Vkg4XHUwMDE4cW1rXHUwMDFmU0RiXHUwMDAyQC10XCIzXHUwMDEyXHUwMDExXXN1dXRLX3ZcdTAwMWFcdTAwMGIyMzhcdTAwMDRJW1x1MDAxYXI9XHU3YjBlXHU3ZWU1Wl9qXHUwMDE4SFx1NGVlMlx1ODgxYWtcdTU3NzhIXHUwMDEzXHUwMDFiI1x1NmM1Ylx1ODgwN2JRUGpcdTAwMThcdTk2NWFcdTVmZDd2YFZbVlx1MDAxYiNcdTgwNWZcdTRlMDJcdTVlZTRaWm9cdTAwMDBIVlx1NGZiOFx1NzQ0ZFx1NTk1Nlx1OGQ0ZUFcdFx1NmI3MGw1XHU5NTc5XHU3MGM2XHU3YjIxXHU3ZWZkXHUwMDE4WlZ2XHU5NTNkXHU1ZDJiXHU1YmY2XHU3NzkyXHUwMDE4XHU1MTE4XHU4MmRkXHU3N2I0YVxiS1x1MDAxZFx1MDAxYi9cdTRmMjVcdThkN2VrTFpTXHUwMDFiXGJsXHUwMDFlYlpKdmVBWmJxTzBDUVx1MDAwNTY3J1hSaFx1MDAwMFhAemlcdTAwMDQvXHUwMDA0SzJtfWBZXHUwMDFhXHU3YjEzXHU3ZTlmSEJma0dIXHUwMDEzXHU3MDRkXHU1MmNhb2xxTksoXHU4MDI4XHU0ZTJkXHU1ZWQwdnpXWEJhcj1kIU4sXHUwMDE4eS5CXHU3MjJmXHU2NTAzXHVmZjdkSFx1MDAwMlxmXHUwMDE1XHJcdTAwMDZcdTAwMDROXHU0ZTdiXHU2Y2IyXHUwMDFiMVZ2aUs2SFx1MDAxNGd1b1x1MDAxOVhcdTAwMDFcdTAwMGVBXHUwMDE4XHUwMDEzdHFWWFRcYn1tJFx1MDAwNlx1MDAxZlx1MDAxYjlcdTAwMWFSVHU5XHU3YjJlXHU3ZWNjQVx0YVx1MDA3ZmdiXHU0ZWVlXHU4ODI0elx1NTcyN0tcdTAwMDR1OVx1NGY0M1x1NWJkOEFcdTAwMTNie3ZiXHU1NDA3XHU0ZTQ1elx1MDAxM1tBbmhcdTAwMTVcdTgwN2JcdTRlMjRcdTVlOWVxeWQwXHU5NTQxXHU3MGQ0XHU3YjEzXHU3ZTlmSER2a1x1OTUxMVx1NWQyN1x1NWJmY1x1NzdjYnFcdTU5NjVcdTk2NzRcdTc3YjFZXHUwMDFheVx1MDA3ZksxXHU4MDQ2XHU1MmQwR0BQXHUwMDBmclx1MDAxNmRcdTAwMWJZXHUwMDFheW9cdTUyNWVcdTkwNTZcdTgwNTNcdWZmNTEoJFFcdTViYzNcdTI1ZjFcdTY4ZTlcYlxyNVx1NWY1Mlx1NTM0Y1x1NjI2Ylx1OTA0OFVcdTAwMGZrR0lNZXhjXHUwMDFha1ZKM2tcdTAwMWRcdTAwMWJcdTAwMTcmXGJcdTAwMWVcdTAwMGZMXHUwMDE0N2V4SkR4cFxyXHUwMDA0OVx1MDAxOFx1MDAwNFx1MDAwNFx1MDAxM11zdXZ1VkouV1x1MDAxY1x1MDAxNzpcdTAwMTRcdTAwMDZcdTAwMWRcdTAwMDBMMD1leEpEeFFcdTAwMGJcdTAwMTk6JFx1MDAxNTRcdTAwMDRAc3V3bidBIn0=@&quot;))); console.log(role_info);return role_info;&#125;function js_eval(js_str) &#123; return eval(&quot;(&quot; + js_str + &quot;)&quot;);&#125;function lpc_2_js(lpc_str) &#123; var convert_dict = &#123; &quot;([&quot;: &quot;&#123;&quot;, &quot;])&quot;: &quot;&#125;&quot;, &quot;,])&quot;: &quot;&#125;&quot;, &quot;(&#123;&quot;: &quot;[&quot;, &quot;&#125;)&quot;: &quot;]&quot;, &quot;,&#125;)&quot;: &quot;]&quot; &#125;; function convert($1) &#123; var match_str = $1.replace(/\s+/g, &apos;&apos;); return convert_dict[match_str]; &#125; var parser = new RegExp(&quot;\\(\\[|,?\s*\\]\\)|\\(&#123;|,?\\s*&#125;\\)&quot;,&apos;g&apos;); return lpc_str.replace(parser, convert);&#125;function decode_desc(ciphertext) &#123; if (ciphertext = ciphertext.replace(/^\s+|\s+$/g, &apos;&apos;), !/^@[\s\S]*@$/.test(ciphertext)) return ciphertext; var _0x36ab38 = &quot;&quot;;//(/\b_k=([^;]*)/.exec(document.cookie) || [])[0x1] || &apos;&apos;; if (ciphertext = ciphertext.replace(/^@|@$/g, &apos;&apos;), /^[^@]+@[\s\S]+/.test(ciphertext)) &#123; var num = ciphertext.indexOf(&apos;@&apos;); _0x36ab38 = ciphertext.substring(0, num), ciphertext = ciphertext.substring(num + 0x1); &#125; debugger; var _0x1b3f48 = function s(ciphertext) &#123; try &#123; return window.eval(&apos;(&apos; + ciphertext + &apos;)&apos;);// &#125; catch (_0x40b9c3) &#123; return null; &#125; &#125;(ciphertext = window.atob(ciphertext));//解码 _0x1b3f48 &amp;&amp; &apos;object&apos; == typeof _0x1b3f48 &amp;&amp; _0x1b3f48[&apos;d&apos;] &amp;&amp; (_0x1b3f48 = _0x1b3f48[&apos;d&apos;]);//从对象&#123;&apos;d&apos;:&apos;xxx&apos;&#125; 取到xxx var str=_0x1b3f48; //numList 是二进制数字的集合 for (var numList = [], j = 0, i =0; i &lt; str.length; i++) &#123; var charCode = str.charCodeAt(i) , _0x341952 = _0x36ab38.charCodeAt(j % _0x36ab38.length);//_0x36ab38 是一个短的字符串 如 QOGBzhZ8hvVKgka8 j ++, charCode = 0x1 * charCode ^ _0x341952, numList.push(charCode.toString(2)); &#125; return function d(ciphertext) &#123; for (var arr = [], i = 0; i &lt; ciphertext.length; i++) arr.push(window.String.fromCharCode(window.parseInt(ciphertext[i], 2))); return arr.join(&apos;&apos;); &#125;(numList); &#125; 另外附上依照此js写的java版本(仅核心代码，其他缺失部分可以自己手动填加)1234567891011121314151617181920212223242526272829303132private static String decodeStr(String ciphertext) throws UnsupportedEncodingException, ScriptException &#123; // 去除前后空格，判断先后字符是否符号特定规则 ciphertext = ciphertext.trim(); if (!(ciphertext.startsWith(&quot;@&quot;) &amp;&amp; ciphertext.endsWith(&quot;@&quot;))) &#123; return ciphertext; &#125; ciphertext = replace(ciphertext, &quot;^@|@$&quot;, &quot;&quot;); // 将字符串分成两部分 int index = ciphertext.indexOf(&quot;@&quot;); String ciphertextPrefix = ciphertext.substring(0, index); String ciphertextSuffix = ciphertext.substring(index + 1); // 对ciphertextSuffix解码 ciphertextSuffix = BtoAAtoB.atob(ciphertextSuffix); Object ciphertextSuffixObj = evalJS(&apos;(&apos; + ciphertextSuffix + &apos;)&apos;); ciphertextSuffix = JSONObject.toJSONString(ciphertextSuffixObj); JSONObject jsonObject = JSONObject.parseObject(ciphertextSuffix); // 从对象&#123;&apos;d&apos;:&apos;xxx&apos;&#125; 取到xxx ciphertextSuffix = jsonObject.get(&quot;d&quot;).toString(); // 转二进制 List&lt;String&gt; numList2 = new ArrayList&lt;String&gt;(); for (int i = 0, j = 0; i &lt; ciphertextSuffix.length(); i++) &#123; char charCode = ciphertextSuffix.charAt(i); char charCode2 = ciphertextPrefix.charAt(j % ciphertextPrefix.length()); j++; int charCodeInt = 1 * (int) charCode ^ (int) charCode2; numList2.add(Integer.toBinaryString(charCodeInt)); &#125; // 转字符串 String byteArrayStr=listTobyte2(numList2); System.out.println(&quot;--------------&quot;); return lpc_2_js(byteArrayStr); &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java基础知识点归纳]]></title>
    <url>%2F2019%2F10%2F01%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[统计了java的知识点，后面的有些自己也没有接触过，需要一步步学习，后期会将学习的东西补充上来 基础 数据类型与字长 switch语句 index for 和foreach labeled loop 异常体系 集合体系结构 迭代器 集合和泛型 强化 LinkedList ArrayList HashMap TreeSet Quene WeakHashMap 集合只读视图 集合同步视图 deprecated集合 线程体系结构 线程状态转换 valatile Atom对象 deprecated线程API File对象 thread local对象 input/output流设计体系 字符编码设置 NIO 正则表达式 反射体系结构 类初始化过程 classloader层次结构设计 进阶 有向图/根节点 GC原理 finalized和GC java安全类库 SQL注入 JDBC socket URL和URI 资源状态错误原理 JDK工具 泛型集合协变 优先级Quene stream与MapReadnve Collections/Arrays/Commons 线程中断 线程/线程组默认处理机制 Callable/Future 线程池/定时器 了解 Semaphore/CountDownlatch/CyclicBarrier JNI：java层与C层数据双向访问 JNI：java层与C层数据双向调用 jNI库生成/加载机制 SecurityManager java二进制保护 JDBC参数调优 数据库连接池参数调优 JIT机制 典型Carbage Collectors原理 GC参数调优 socket与ososI协议栈资源管理 java层线程/C层线程/OS线程/CPU核（物理线程）关系 class格式 栈帧结构 klass-oop]]></content>
  </entry>
  <entry>
    <title><![CDATA[AK/SK认证方式]]></title>
    <url>%2F2019%2F08%2F22%2FAK-SK%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[AK/SK认证是对请求消息按照一定规则生成签名信息，服务器对签名信息进行安全认证，主要作用是保证请求的可靠性，完整性。 ak表示公钥，sk表示私钥。ak与sk一一对应，不同的域使用不同的aksk. 下面提供一个简单的签名认证方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class AKSKImpl &#123; private static String AK=&quot;123456789&quot;; private static String SK=&quot;012345&quot;; public static void main(String[] args) throws Exception &#123; String str= sign(&quot;1234.do&quot;,&quot;11111111&quot;,&quot;11111&quot;,AK,SK); System.out.println(str); &#125; private static String sign(String url,String dateTime,String numNoice,String ak,String sk) throws Exception&#123; String data= ak+url +numNoice+dateTime; String sign=hamcsha1(data.getBytes(&quot;UTF-8&quot;),sk.getBytes(&quot;UTF-8&quot;)); return sign; &#125; public static String hamcsha1(byte[] data, byte[] key) &#123; try &#123; SecretKeySpec signingKey = new SecretKeySpec(key, &quot;HmacSHA1&quot;); Mac mac = Mac.getInstance(&quot;HmacSHA1&quot;); mac.init(signingKey); return byte2hex(mac.doFinal(data)); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; //二行制转字符串 public static String byte2hex(byte[] b) &#123; StringBuilder hs = new StringBuilder(); String stmp; for (int n = 0; b!=null &amp;&amp; n &lt; b.length; n++) &#123; stmp = Integer.toHexString(b[n] &amp; 0XFF); if (stmp.length() == 1) hs.append(&apos;0&apos;); hs.append(stmp); &#125; return hs.toString().toUpperCase(); &#125;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新公司的体验]]></title>
    <url>%2F2019%2F04%2F09%2F%E6%96%B0%E5%85%AC%E5%8F%B8%E7%9A%84%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[新入职公司快两个月的时间了，中间因为搬家还有入职后的乱七八糟的事情，感觉周末过的一直不怎么舒服。现在抽出点时间来记录下新公司与之前公司的区别。 新公司比以前公司要累很多（事情多，没人带，新东西没人教，很多人推三阻四），以前的公司以业务为主，能实现就行，新公司的要求更高，代码质量，文档，需求确认，安全， 新公司的流程更加规范，体现在代码提交规范，业务开发流程，测试流程，提交各种电子流流程（请假，转正，补签到等）。虽然刚开始可能会不习惯，弄着弄那的觉得很烦，但是因为流程规范，实施起来是绝对遵从的（比如年假制度，工资发放，调休制度）。 除了上班时间，下班离开公司后很少烦你。 与大佬接触的更多，可能学到的东西更多。 能专注于java后端，前端服务器维护这些不用再了解过深，有更多的时间去钻研一个方向。 开发的产品是绝对有市场需求的，不会突然暴死，遇到的实际问题更多，对自己成长有益。 团队更大，有助于增加协作经验。 希望自己能在这里发展的更好。]]></content>
  </entry>
  <entry>
    <title><![CDATA[【请停用以开发者模式运行的扩展程序】取消]]></title>
    <url>%2F2019%2F03%2F30%2F%E3%80%90%E8%AF%B7%E5%81%9C%E7%94%A8%E4%BB%A5%E5%BC%80%E5%8F%91%E8%80%85%E6%A8%A1%E5%BC%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A9%E5%B1%95%E7%A8%8B%E5%BA%8F%E3%80%91%E5%8F%96%E6%B6%88%2F</url>
    <content type="text"><![CDATA[作为程序员，chrome的使用必不可少，Chrome应用商店的扩展更是chrome的一大特色，但是经常使用这些扩展的，如果不是从应用商店下载的，每次启动的时候总会会有一个烦人的请停用以开发者模式运行的扩展程序提示。虽然他不影响自己的工作，每次启动后随手点击下就可关闭，但是每次启动都要点击一下也挺费事，下面提供了一个一劳永逸的办法。 2020-03-28 更新大约从Chrome79开始，使用上面的 version.dll替换会导致Chrome浏览器直接崩溃掉，需要换成这个更新的：version_v79.dll ，使用方法还是一样，解压后找到指定系统位数的version.dll放在和Chrome.exe同目录后重启Chrome即可。 下载地址http://file.haoji.me/detail/27 2020-04-05 更新如果是wind10的话，推荐安装微软的chrome内核的edge,和chrome基本一样，功能上更好用一些。下载地址：https://www.microsoft.com/zh-cn/edge]]></content>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[www.google.com网站打开一直显示证书无效，指向vmware]]></title>
    <url>%2F2019%2F01%2F05%2Fwww-google-com%E7%BD%91%E7%AB%99%E6%89%93%E5%BC%80%E4%B8%80%E7%9B%B4%E6%98%BE%E7%A4%BA%E8%AF%81%E4%B9%A6%E6%97%A0%E6%95%88%EF%BC%8C%E6%8C%87%E5%90%91vmware%2F</url>
    <content type="text"><![CDATA[最近打开google搜索时，一直打不开www.google.com域名下的所有网页（其他的网页都可以打开，把默认搜索网址改为了https://ipv4.google.com/search），显示不是安全的链接，点开域名前的锁，显示域名无效。近期也安装了vmWare,然后www.google.com的颁发者和颁布者全部指向了VMWare。然后一直以为是VMWare的问题或者是www.google.com的证书问题。在网上重新安装了www.google.com的证书，VMWare也重新卸载安装，还是一直不行。后来无意间ping www.google.com时，发现ip竟然指向了 127.0.0.1,查询下本地hosts文件，并没有 定义www.google.com的ip。最后在网上查了下问题，可能是dns劫持的问题，修改dns为114然后在网上查了下问题，可能是dns劫持的问题，修改dns为114.114.114.114，备用为8.8.8.8。问题得以解决 就这个问题，在网上找到的有以下解决办法，都可以试一试。 办法 一安装了www.google.com的证书。下载地址：https://pki.google.com/GIAG2.crt 办法 二重新安装或者修复VMWare，chrome。 办法 三ping www.google.com，如果ip为127.0.0.1。则将自动获取dns服务地址，改为选用下面的dns服务地址。首选dns服务器：114.114.114.114备用dns服务器：8.8.8.8]]></content>
      <tags>
        <tag>google</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TortoiseSVN在win10安装后,svn地址获取的文件没有对勾感叹号]]></title>
    <url>%2F2018%2F12%2F30%2FTortoiseSVN%E5%9C%A8win10%E5%AE%89%E8%A3%85%E5%90%8E-svn%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%8F%96%E7%9A%84%E6%96%87%E4%BB%B6%E6%B2%A1%E6%9C%89%E5%AF%B9%E5%8B%BE%E6%84%9F%E5%8F%B9%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[今天在新电脑上安装TortoiseSVN后，根据svn地址获取代码，但是获取的代码文件前没有显示对勾感叹号等。后来在网上寻找解决方案。 方案1在注册表中查询ShellIconOverlayIdentifiers文件下内容看一下名字中带有Tortoise的文件夹是否排在最前面，如果不是的话，修改文件名（在文件名前面加空格就行），使带有Tortoise的文件夹排在最前面。具体操作如下：在运行里 输入 regedit 进入 注册表界面,HKEY_LOCAL_MACHINE-&gt;SOFTWARE-&gt;Microsoft-&gt;Windows-&gt;CurrentVersion-&gt;Explorer-&gt;ShellIconOverlayIdentifiers打开后发现Tortoise 系列（1TortoiseNormal,2TortoiseAdded等）前面有好多项,Tortoise系列排到了15名之后,难怪不显示。现在的任务就是把它们提到前面了,修改一下它们的名字就好（我是看第一项的前缀是空格,说明空格的字符排序在前面,我就加了几个空格）,我改后的名字如（ TortoiseNormal,TortoiseAdded等）,然后关闭再打开注册表,发现Tortoise系列系列图标已经排到前面了。最后重启电脑，再看下svn获取文件，发下左下角图标已经显示了。 方案2第二个方法是在svn获取地址的文件下右键文件夹—&gt;TortoiseSVN—&gt;Settings—&gt;Icon Overlays（图标覆盖） —&gt;（ Status cache下—&gt;Shell前打对勾，Drives Types下—&gt;Fixed drives前面打对勾 ）这样就可以了。 我是通过第一种方法解决问题的。第二种情况应该很少出现。 参考地址参考地址1：https://blog.csdn.net/shichuwu/article/details/79808560参考地址2：https://blog.csdn.net/Love_Legain/article/details/68489912]]></content>
      <tags>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql中遇到的奇怪问题]]></title>
    <url>%2F2018%2F12%2F05%2Fmysql%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%A5%87%E6%80%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[创建表1234CREATE TABLE `testtable` ( `id` varchar(32) DEFAULT NULL, `num` int(10) DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据12345INSERT INTO `testtable` VALUES (&apos;111111111111&apos;, &apos;1&apos;);INSERT INTO `testtable` VALUES (&apos;222222222222&apos;, &apos;0&apos;);INSERT INTO `testtable` VALUES (&apos;333333333333&apos;, &apos;0&apos;);INSERT INTO `testtable` VALUES (&apos;444444444444&apos;, &apos;0&apos;);INSERT INTO `testtable` VALUES (&apos;555555555555&apos;, &apos;1&apos;); 查询语句1234--语句1select * from testtable where num =&quot;r&quot;=&quot;fff&quot;;--语句2select &quot;r&quot;=&quot;t&quot; ; 语句1中 查询结果为 id num 111111111111 1 555555555555 1 语句2结果为 “r”=”t” 0 分析：按照网上查找的说法select from testtable where num =”r”=”fff”;中会执行顺序为先执行括号中的 select from testtable where num = (“r”=”fff”);select “r”=”t” ;查询结果为 0；按理说语句1应该对应 select from testtable where num = 0；但是查出来的结果为 select from testtable where num = 1；的执行结果。 这种问题是什么原因？]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 注册表字符集]]></title>
    <url>%2F2018%2F12%2F05%2Foracle-%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%AD%97%E7%AC%A6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Oracle中字符集的问题。有些数据库中存的特殊字符，在读出来后，有的电脑上显示为问号。 解决办法：在注册表中搜索NLS_LANG，设置为 SIMPLIFIED CHINESE_CHINA.ZHS16GBK 可以在oracle中查询 NLS_LANGselect userenv(‘language’) from dual ；SIMPLIFIED CHINESE_CHINA.AL32UTF8。 好吧。最后发现的问题是，导出脚本为sql,数据库存的特殊字符没法识别，转换为？。最后的解决办法是，将含有特殊字符的表导出为dmp格式。重新导入就好了。]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlserver数据库sa用户密码设置]]></title>
    <url>%2F2018%2F12%2F03%2Fsqlserver%E6%95%B0%E6%8D%AE%E5%BA%93sa%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[sql server 客户端登录数据库有两种方式。一种是 windows 身份验证。一种是使用sql server 身份验证（登录名，密码），这种一般是写程序连接时使用的方式。 有些用户装数据库时，直接默认一步一步点下来，这样sqlserver 装好后，只有windows 身份验证这一种登录方式。 在程序连接的时候，这个时候就需要sql server 身份验证，需要重新启用sa用户。 这下改如何设置？ 先使用 windows 身份验证登录上。对象资源管理器中，树菜单，右击根节点–》属性–》安全性–》服务器身份验证，改为sql server 和windows身份验证。 树菜单的二级菜单中点击安全性–》登录名–》右击sa–》属性–》常规中，设置密码。状态中，设置为已启用。 右键根节点–》重新启动。 使用sql server 登录 ，如果成功登录，即完成。 如果遇到登录没有权限，注意上面步骤中的sa属性状态设置为 已启用。]]></content>
  </entry>
  <entry>
    <title><![CDATA[windows下界面的快捷命令]]></title>
    <url>%2F2018%2F12%2F02%2Fwindows%E4%B8%8B%E7%95%8C%E9%9D%A2%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[一些常用的windows界面的快捷命令，通过运行（windows+R 键打开）来执行 12345678910111213cmd dos命令窗口regedit 打开注册表msconfig 系统配置（包括启动项，服务等）calc 打开计算器notepad 打开记事本compmgmt.msc 计算机管理mstsc 打开windows远程桌面连接at 01:30 shutdown -s 在1点30分自动关机shutdown -s 关机（默认1分钟后关）shutdown -s -t 3600 一小时后自动关机shutdown -r 重启shutdown -a 取消定时任务services.msc 打开服务]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql多表多条件查询技巧]]></title>
    <url>%2F2018%2F11%2F26%2Fsql%E5%A4%9A%E8%A1%A8%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[具体代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980sql = @&quot;select A.JID,A.JH,A.CX,A.CZ,B.HZB HZZ,B.ZZB FROM DEF_WELL_TAG A left JOIN sc_well_location B ON A.JID=B.JID &#123;1&#125; WHERE A.QTID=&apos;&#123;0&#125;&apos;AND A.JID IN (SELECT CC.JID FROM SC_WILD_ZONATION CC , SC_LAYER_T DD WHERE 1 = 1 AND DD.JID = CC.JID)&quot;;string filterStr = string.Empty;foreach (string filter in filterCondition)&#123; filterStr = filterStr + filter + &quot;,&quot;;&#125;string oldChart = &quot;B&quot;;string inserSQL = string.Empty;if (filterStr.IndexOf(&quot;有设计报告,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct jingid as JID from DOC_DOCUMENT_TARGET where path=&apos;单井资料\钻井资料\地质设计&apos; and JINGID is not null) C ON &#123;0&#125;.JID=C.JID&quot;; inserSQL=string.Format(inserSQL,oldChart); oldChart=&quot;C&quot;;&#125;if (filterStr.IndexOf(&quot;有日产数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select CC.JID FROM DEF_WELL_TAG CC JOIN (SELECT distinct BB.ZJMC FROM DC_GAS_WELL_VOL_DAILY AA JOIN DEF_WELL_TAG BB ON AA.JID=BB.JID)DD ON CC.JH=DD.ZJMC) D ON &#123;0&#125;.JID=D.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;D&quot;;&#125;if (filterStr.IndexOf(&quot;有测井解释,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from SC_LOG_INTERPRET_RESULT) E ON &#123;0&#125;.JID=E.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;E&quot;;&#125;if (filterStr.IndexOf(&quot;有井斜数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from SC_INDINATION) F ON &#123;0&#125;.JID=F.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;F&quot;;&#125;if (filterStr.IndexOf(&quot;有压恢数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN ((select distinct JID from DC_TEST_GAS) union (select distinct JID from DC_TEST_GATHER)) G ON &#123;0&#125;.JID=G.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;G&quot;;&#125;if (filterStr.IndexOf(&quot;有射孔数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from DC_PERFORATE_T) H ON &#123;0&#125;.JID=H.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;H&quot;;&#125;if (filterStr.IndexOf(&quot;有大分层数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from SC_WILD_ZONATION) I ON &#123;0&#125;.JID=I.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;I&quot;;&#125;if (filterStr.IndexOf(&quot;有FMT/RFT数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN ((select distinct JID from SC_FMT_LOG_RESULT) union (select distinct JID from SC_RFT_LOG_RESULT)) J ON &#123;0&#125;.JID=J.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;J&quot;;&#125;if (filterStr.IndexOf(&quot;有复杂情况数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from SC_COMPLEX_EXPLAIN) K ON &#123;0&#125;.JID=K.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;K&quot;;&#125;if (filterStr.IndexOf(&quot;有气测录井数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from SC_OILINESS_SHOW) L ON &#123;0&#125;.JID=L.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;L&quot;;&#125;if (filterStr.IndexOf(&quot;有钻井液使用数据,&quot;) &gt;= 0)&#123; inserSQL += @&quot; JOIN (select distinct JID from SC_FLUID_CAPABILITY) M ON &#123;0&#125;.JID=M.JID&quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;M&quot;;&#125;sql = string.Format(sql, zyqID, inserSQL); 例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960sql = @&quot;select distinct A.JID,A.JH,A.CX,A.CZ,B.HZB HZZ,B.ZZB FROM DEF_WELL_TAG A left JOIN sc_well_location B ON A.JID=B.JID &#123;1&#125; WHERE A.QTID=&apos;&#123;0&#125;&apos; AND A.JID IN (SELECT CC.JID FROM SC_WILD_ZONATION CC , SC_LAYER_T DD WHERE 1 = 1 AND DD.JID = CC.JID) &#123;2&#125; &quot;;string oldChart = &quot;B&quot;;string inserSQL = string.Empty;string inserSQL2 = string.Empty;if (filterCondition[&quot;ceDafencengshuju&quot;].Equals(&quot;1&quot;))&#123;//大分层数据 inserSQL += @&quot; JOIN ( select distinct jid from SC_WILD_ZONATION ) C ON &#123;0&#125;.JID=C.JID &quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;C&quot;;&#125;if (filterCondition[&quot;ceXifencengshuju&quot;].Equals(&quot;1&quot;))&#123;//细分层数据 inserSQL += @&quot; JOIN ( select distinct jid from SC_LAYER_T ) D ON &#123;0&#125;.JID=D.JID &quot;; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;D&quot;;&#125;if (filterCondition[&quot;ceFanwei&quot;].Equals(&quot;1&quot;))&#123;//半径范围 if (!string.IsNullOrEmpty(filterCondition[&quot;teRadius&quot;])) &#123; string x=filterCondition[&quot;x&quot;]; string y=filterCondition[&quot;y&quot;]; string radius = filterCondition[&quot;teRadius&quot;]; // t.ZZB - &#123;1&#125;) * (t.ZZB - &#123;1&#125;) + (t.HZB - &#123;2&#125;) * (t.HZB - &#123;2&#125;); inserSQL += @&quot; JOIN ( select jid ,zzb,hzb from sc_well_location ) E ON &#123;0&#125;.JID=E.JID and (E.ZZB - &#123;1&#125;) * (E.ZZB - &#123;1&#125;) + (E.HZB - &#123;2&#125;) * (E.HZB - &#123;2&#125;) &lt; &#123;3&#125;*&#123;3&#125; &quot;; inserSQL = string.Format(inserSQL, oldChart,y,x,radius); oldChart = &quot;E&quot;; &#125;&#125;if (filterCondition[&quot;ceGuanxixuanjing&quot;].Equals(&quot;1&quot;))&#123;//层系层组选井 inserSQL += @&quot; JOIN ( select distinct jid, CX, CZ from DEF_WELL_TAG ) F ON &#123;0&#125;.JID=F.JID &quot;; if (!string.IsNullOrEmpty(filterCondition[&quot;cbCengxi&quot;])) &#123; inserSQL += &quot;AND F.CX in (select dm from DEF_STRATUM_SYSTEM_TAG where cxjc= &apos;&quot; + filterCondition[&quot;cbCengxi&quot;] + &quot;&apos;) &quot;; &#125; if (!string.IsNullOrEmpty(filterCondition[&quot;cbCengzu&quot;])) &#123; inserSQL += &quot;AND F.CZ in (select dm from DEF_STRATUM_ORGANISE where czjc= &apos;&quot; + filterCondition[&quot;cbCengzu&quot;] + &quot;&apos;) &quot;; &#125; inserSQL = string.Format(inserSQL, oldChart); oldChart = &quot;F&quot;;&#125;if (filterCondition[&quot;ceJinghao&quot;].Equals(&quot;1&quot;))&#123;//井号 if(!string.IsNullOrEmpty(filterCondition[&quot;teJinghao&quot;])) &#123; inserSQL2 += @&quot; AND A.JH LIKE &apos;%&quot; + filterCondition[&quot;teJinghao&quot;] + &quot;%&apos; &quot;; &#125;&#125;sql = string.Format(sql, zyqID, inserSQL, inserSQL2);]]></content>
  </entry>
  <entry>
    <title><![CDATA[varchar、nvarchar、char、nchar区别和使用]]></title>
    <url>%2F2018%2F11%2F14%2Fvarchar%E3%80%81nvarchar%E3%80%81char%E3%80%81nchar%E5%8C%BA%E5%88%AB%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[SQLServer中有char、varchar、nchar、nvarchar四种类型来对应（暂时不考虑text和ntext），开建立数据库中，对这四种类型往往比较模糊，这里做一下对比。 1 定长或变长1所谓定长就是长度固定的，当输入的数据长度没有达到指定的长度时将自动以英文空格在其后面填充，使长度达到相应的长度；有var前缀的，表示是实际存储空间是变长的，比如varchar,nvarchar变长字符数据则不会以空格填充，比较例外的是，text存储的也是可变长。 2 Unicode或非Unicode1数据库中，英文字符只需要一个字节存储就足够了，但汉字和其他众多非英文字符，则需要两个字节存储。如果英文与汉字同时存在，由于占用空间数不同，容易造成混乱，导致读取出来的字符串是乱码。Unicode字符集就是为了解决字符集这种不兼容的问题而产生的，它所有的字符都用两个字节表示，即英文字符也是用两个字节表示。而前缀n就表示Unicode字符，比如nchar,nvarchar，这两种类型使用了Unicode字符集。 3 基于以上两点来看看字段容量|—|—||char，varchar|最多8000个英文，4000个汉字||nchar，nvarchar|可存储4000个字符，无论英文还是汉字||—|—| 4 使用(个人偏好)1234如果数据量非常大，又能100%确定长度且保存只是ansi字符，那么char 能确定长度又不一定是ansi字符或者，那么用nchar； 对于超大数据，如文章内容，使用nText 其他的通用nvarchar char、varchar、nchar、nvarchar特点比较 CHARCHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间。 VARCHAR存储变长数据，但存储效率没有CHAR高,如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么”+1”呢？这一个字节用于保存实际使用了多大的长度。 1从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。 TEXTtext存储可变长度的非Unicode数据，最大长度为2^31-1(2,147,483,647)个字符。 NCHAR、NVARCHAR、NTEXT这三种从名字上看比前面三种多了个”N”。和char、varchar比较起来，nchar、nvarchar最多存储4000个字符，不论是英文还是汉字；而char、varchar最多能存储8000个英文，4000个汉字。可以看出使用nchar、nvarchar数据类型时不用担心输入的字符是英文还是汉字，较为方便，但在存储英文时数量上有些损失。 1所以一般来说，如果含有中文字符，用nchar/nvarchar，如果纯英文和数字，用char/varchar。 参考地址char、varchar、nchar、nvarchar的区别:http://www.cnblogs.com/smjack/archive/2008/04/14/1152342.html]]></content>
      <tags>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具网站记录]]></title>
    <url>%2F2018%2F10%2F25%2F%E5%B7%A5%E5%85%B7%E7%BD%91%E7%AB%99%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[12345--下载google play apkhttps://apkpure.com/https://sameapk.comhttp://apkfind.com将google play中的apk地址复制进去就可以下载 12C#的反编译工具ILYpy 1234567pdf转word网站https://smallpdf.com/每天可以免费两次，如果需要多转，清除cookie即可不过现在office2016已经可以pdf转word了对于图片类的pdf,可以使用工具ABBYYFineReader2012ProfessionalPortable]]></content>
  </entry>
  <entry>
    <title><![CDATA[语法错误: 应为标识符或带引号的标识符]]></title>
    <url>%2F2018%2F10%2F24%2F%E8%AF%AD%E6%B3%95%E9%94%99%E8%AF%AF-%E5%BA%94%E4%B8%BA%E6%A0%87%E8%AF%86%E7%AC%A6%E6%88%96%E5%B8%A6%E5%BC%95%E5%8F%B7%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[在使用C#执行sql的过程中，在plsql中执行没错，在程序中执行的话，就会提示”语法错误: 应为标识符或带引号的标识符”以下错误 解决办法 包含子查询的将子查询去掉用联合查询来做 例子: 12345678--原sql为 select rownum r, t2.well_name,t2.layers,t2.top_deep,t2.bottom_deep,t2.middle_deep,t2.pressure,t2.pressure_coefficient,t2.test_date,t2.remark from (select t1.well_name well_name,t1.layers layers,t1.top_deep top_deep,t1.bottom_deep bottom_deep,t1.middle_deep middle_deep,t1.pressure pressure,t1.pressure_coefficient pressure_coefficient,t1.test_date test_date,t1.remark remark from cd_pressure_coefficient t1 where t1.doc_id=&apos;&#123;0&#125;&apos; order by test_date ) t2 --改为 select t1.well_name well_name,t1.layers layers,t1.top_deep top_deep,t1.bottom_deep bottom_deep,t1.middle_deep middle_deep,t1.pressure pressure,t1.pressure_coefficient pressure_coefficient,t1.test_date test_date,t1.remark remark from cd_pressure_coefficient t1 left join dual t1 where t1.doc_id=&apos;&#123;0&#125;&apos; order by test_date]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 导入带有BLOB类型字段的表时修改表空间]]></title>
    <url>%2F2018%2F10%2F12%2Foracle-%E5%AF%BC%E5%85%A5%E5%B8%A6%E6%9C%89BLOB%E7%B1%BB%E5%9E%8B%E5%AD%97%E6%AE%B5%E7%9A%84%E8%A1%A8%E6%97%B6%E4%BF%AE%E6%94%B9%E8%A1%A8%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[正常使用imp/exp时。先导出源库，再创建新库把表空间创建好，然后再导入。即使用户名表空间都不同，但也能正常导入。即导出的表的表空间不存在，会默认添加到导入用户名下的默认表空间中。 特殊情况如果涉及到BOLB字段的表，导入时会出现错误，提示表空间不存在（即导出的表的表空间与导入用户的表空间不一样）。 含有BOLB字段的表用sql导入时会很麻烦，正常情况下没法导入。一般都是使用dmp文件导入。 错误方法第一次处理时把原先导出数据的表空间创建一次，正常导入，再在数据库修改表和索引的表空间，这样处理的问题是,修改完后，表数据全部丢失。 正确方法使用UltraEdit工具，编辑打开dmp文件。切换为文本模式，把以前的表空间替换为现在需要导入的表空间，目前这种方法对于数据量小的表可以使用。数据量大的情况下待测试。 其他方法还有找到了其他的正统方法， 链接 https://www.cnblogs.com/xd502djj/archive/2010/11/21/1883467.html]]></content>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oracle 常用函数记录]]></title>
    <url>%2F2018%2F10%2F10%2Foracle-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617ROUND() 函数 ：用于把数值字段舍入为指定的小数位数。 to_char()函数：转化数字型指定小数点位数的用法/* to_char(0.1,'fm9999990.00') */ 格式化to_number()to_date('2012-08-31','yyyy-mm-dd')TRUNC（number,[num_digits]）TRUNC 函数语法具有下列参数：Number 必需。需要截尾取整的数字。Num_digits 可选。用于指定取整精度的数字。Num_digits 的默认值为 0（零）trim() 去首尾空字符串]]></content>
  </entry>
  <entry>
    <title><![CDATA[数学计算公式]]></title>
    <url>%2F2018%2F09%2F28%2F%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[对于以下表：An,Bn,是实数 An Bn A1 B1 A2 B2 A3 B3 以下公式 1min(Bn-An) + max (An-Bn)=0]]></content>
  </entry>
  <entry>
    <title><![CDATA[特殊字符记录]]></title>
    <url>%2F2018%2F09%2F22%2F%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[123456789上标数字及符合⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ⁽ ⁾下标数字及符合₀ ₁ ₂ ₃ ₄ ₅ ₆ ₇ ₈ ₉ ₊ ₋ ₌ ₍ ₎完整的上标字符ᵃ ᵇ ᶜ ᵈ ᵉ ᵍ ʰ ⁱ ʲ ᵏ ˡ ᵐ ⁿ ᵒ ᵖ ᵒ⃒ ʳ ˢ ᵗ ᵘ ᵛ ʷ ˣ ʸ ᙆ ᴬ ᴮ ᒼ ᴰ ᴱ ᴳ ᴴ ᴵ ᴶ ᴷ ᴸ ᴹ ᴺ ᴼ ᴾ ᴼ̴ ᴿ ˢ ᵀ ᵁ ᵂ ˣ ᵞ ᙆ ꝰ ˀ ˁ ˤ ꟸ ꭜ ʱ ꭝ ꭞ ʴ ʵ ʶ ꭟ ˠ ꟹ ᴭ ᴯ ᴲ ᴻ ᴽ ᵄ ᵅ ᵆ ᵊ ᵋ ᵌ ᵑ ᵓ ᵚ ᵝ ᵞ ᵟ ᵠ ᵡ ᵎ ᵔ ᵕ ᵙ ᵜ ᶛ ᶜ ᶝ ᶞ ᶟ ᶡ ᶣ ᶤ ᶥ ᶦ ᶧ ᶨ ᶩ ᶪ ᶫ ᶬ ᶭ ᶮ ᶯ ᶰ ᶱ ᶲ ᶳ ᶴ ᶵ ᶶ ᶷ ᶸ ᶹ ᶺ ᶼ ᶽ ᶾ ᶿ ꚜ ꚝ ჼ ᒃ ᕻ ᑦ ᒄ ᕪ ᑋ ᑊ ᔿ ᐢ ᣕ ᐤ ᣖ ᣴ ᣗ ᔆ ᙚ ᐡ ᘁ ᐜ ᕽ ᙆ ᙇ ᒼ ᣳ ᒢ ᒻ ᔿ ᐤ ᣖ ᣵ ᙚ ᐪ ᓑ ᘁ ᐜ ᕽ ᙆ ᙇ ⁰ ¹ ² ³ ⁴ ⁵ ⁶ ⁷ ⁸ ⁹ ⁺ ⁻ ⁼ ˂ ˃ ⁽ ⁾ ˙ * º完整的下标字符ₐ ₔ ₑ ₕ ᵢ ⱼ ₖ ₗ ₘ ₙ ₒ ₚ ᵣ ₛ ₜ ᵤ ᵥ ₓ ᙮ ᵤ ᵩ ᵦ ₗ ˪ ៳ ៷ ₒ ᵨ ₛ ៴ ᵤ ᵪ ᵧ]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql遇到的问题]]></title>
    <url>%2F2018%2F09%2F20%2Fsql%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.相同条件取出多条数据，筛选出一个表同井号中最大年份的数据，12345-- 1.先计算出每个井号的最大年份select JH,MAX(ND) nd from SC_WILD_ZONATION group BY JH ；-- 2。与自身关联，查询出需要其他的数据SELECT t1.JID,t1.K1,t1.K2,t1.K3,t1.K4,t1.K5,t1.K6,t1.K7,t1.K8,t1.K9,t1.K10,t1.K11,t1.K12,t1.K13 ,t1.ND FROM SC_WILD_ZONATION t1 inner join (select JH,MAX(ND) nd from SC_WILD_ZONATION group BY JH) t2 on t1.JH=t2.JH and t2.nd= t1.ND ； sql server 日期操作问题123456-- 上个月最后一天select DATEADD(ms,-3,DATEADD(MONTH,DATEDIFF(MONTH,0,GETDATE()),0));-- 上个月第一天select DATEADD(MONTH,DATEDIFF(MONTH,0, DATEADD(ms,-3,DATEADD(MONTH,DATEDIFF(MONTH,0,GETDATE()),0)) ),0);--参考&lt;http://www.cnblogs.com/lcyuhe/p/5613632.html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[nginx https配置]]></title>
    <url>%2F2018%2F09%2F08%2Fnginx-https%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[购买阿里云免费ssh证书购买证书页面https://common-buy.aliyun.com/?spm=5176.7968328.1120760.1.1b8f12329uxmQj&amp;commodityCode=cas#/buy购买页面如果选择到免费证书https://yq.aliyun.com/articles/221596?spm=5176.10695662.1996646101.searchclickresult.1f677d54LcbjNk ssh证书控制台https://yundun.console.aliyun.com/?spm=5176.7968328.1120760.1.1b8f12329uxmQj&amp;p=cas#/cas/home 配置域名 在阿里云ssh控制台 查看证书信息，补全信息，里面填写需要加ssh链接的 域名信息–&gt;个人信息–&gt;相关信息。 在证书项目信息里查看 记录值 和 主机记录 ，下一步会有用到。此时证书状态为未审核。 在域名解析列表配置上 ,点击 添加记录，内容填写如下： |记录类型| TXT||主机记录|（上一步查询到的值）||解析路线|默认||记录值|（上一步查询到的值||TTL|10分钟| 过上一两个小时，在证书信息页面查看证书状态是否已经变为 已签发。 这样配置域名配置就结束了，接下来是对nginx服务添加证书。点击列表后面的下载证书。 安装证书 （以下内容取自阿里云的下载证书页面）文件说明：1234567891011121314151617181920212223242526272829303132333435363738394041421. 证书文件214983143490997.pem，包含两段内容，请不要删除任何一段内容。2. 如果是证书系统创建的CSR，还包含：证书私钥文件214983143490997.key。( 1 ) 在Nginx的安装目录下创建cert目录，并且将下载的全部文件拷贝到cert目录中。如果申请证书时是自己创建的CSR文件，请将对应的私钥文件放到cert目录下并且命名为214983143490997.key；( 2 ) 打开 Nginx 安装目录下 conf 目录中的 nginx.conf 文件，找到：# HTTPS server# #server &#123;# listen 443;# server_name localhost;# ssl on;# ssl_certificate cert.pem;# ssl_certificate_key cert.key;# ssl_session_timeout 5m;# ssl_protocols SSLv2 SSLv3 TLSv1;# ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;# ssl_prefer_server_ciphers on;# location / &#123;###&#125;#&#125;( 3 ) 将其修改为 (以下属性中ssl开头的属性与证书配置有直接关系，其它属性请结合自己的实际情况复制或调整) :server &#123; listen 443; server_name localhost; ssl on; root html; index index.html index.htm; ssl_certificate cert/214983143490997.pem; ssl_certificate_key cert/214983143490997.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; &#125;&#125;保存退出。( 4 )重启 Nginx。( 5 ) 通过 https 方式访问您的站点，测试站点证书的安装配置。如遇到证书不信任问题，请查看帮助视频。]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux 下svn服务部署]]></title>
    <url>%2F2018%2F09%2F07%2Flinux-%E4%B8%8Bsvn%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[准备服务端系统 Centos7.4客户端系统 win7或者linux官网下载：http://subversion.apache.org/packages.htmlSVN客户端：TortoiseSVN，官网下载：http://tortoisesvn.net/downloads.html ，windows系统直接点击安装就可以装好客户端了。 安装SVN服务端安装svn能连接外网的话用yum 直接安装1yum install subversion 1.新建一个目录用于存储SVN所有文件1mkdir /usr/svn 2.新建一个资源仓库1svnadmin create /usr/svn/blog.wziyou.top 可以查看到1ls /usr/svn/blog.wziyou.top 1conf db format hooks locks README.txt 说明 hooks目录：放置hook脚本文件的目录 locks目录：用来放置subversion的db锁文件和db_logs锁文件的目录，用来追踪存取文件库的客户端 format文件：是一个文本文件，里面只放了一个整数，表示当前文件库配置的版本号 conf目录：是这个仓库的配置文件（仓库的用户访问账号、权限等） 3. 配置svn服务的配置文件svnserver.conf文件1vim /usr/svn/blog.wziyou.top/conf/svnserve.conf 修改或添加以下信息(注意顶格写，别有空格)，保存123456[general]anon-access = noneauth-access = writepassword-db = /usr/svn/blog.wziyou.top/conf/passwdauthz-db =/usr/svn/blog.wziyou.top/conf/authzrealm = wz's blog by hexo #这是个提示信息 4.添加三个访问用户及口令1vim /usr/svn/blog.wziyou.top/conf/passwd 修改或添加以下信息(注意顶格写，别有空格，等号左边是账号，后边是密码)，保存1234[users]wziyou = wziyoutest1 = 123456test2 = 123456 5.配置新用户的授权文件1vim /usr/svn/blog.wziyou.top/conf/authz 修改或添加以下信息(注意顶格写，别有空格)，保存1234567[groups]admin = wziyou,test1user = test2[/]@admin = rw@user = r*= 代表的意思是 给wziyou,test1俩个用户 admin 角色，admin角色具有rw(读写)权限，user 同理。*=表示除了上面设置的权限用户组以外，其他所有用户都设置空权限，空权限表示禁止访问本目录，这很重要一定要加上。 6.启动svn服务默认svn服务器端口是3690。1svnserve -d -r /usr/svn/blog.wziyou.top 使用客户端连接windows 系统使用TortoiseSVN Repository Browser工具打开 在一个空文件夹下右击，选择 svn checkout 输入svn://你的ip地址/blog.wziyou.top 弹窗内输入 账号密码，ok 即可检出项目 linux 系统使用如下命令1svn co svn://你的ip地址 co 是checkout简称，也可以写成1svn checkout svn://你的ip地址 参考地址 感谢https://my.oschina.net/lionel45/blog/298305]]></content>
      <tags>
        <tag>svn</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 日期操作扩展]]></title>
    <url>%2F2018%2F09%2F07%2Fjs-%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[内容123456789101112131415161718192021222324252627282930313233343536373839Date.isLeapYear = function (year) &#123; return (((year % 4 === 0) &amp;&amp; (year % 100 !== 0)) || (year % 400 === 0));&#125;;Date.getDaysInMonth = function (year, month) &#123; return [31, (Date.isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];&#125;;Date.prototype.isLeapYear = function () &#123; return Date.isLeapYear(this.getFullYear());&#125;;Date.prototype.getDaysInMonth = function () &#123; return Date.getDaysInMonth(this.getFullYear(), this.getMonth());&#125;;Date.prototype.addMonths = function (value) &#123; var n = this.getDate(); this.setDate(1); this.setMonth(this.getMonth() + value); this.setDate(Math.min(n, this.getDaysInMonth())); return this;&#125;;Date.prototype.addDays = function(days) &#123; var date = new Date(this.valueOf()); date.setDate(date.getDate() + days); return date;&#125;//时间格式化 年月日时分秒function dateymdhis(value)&#123; var date = new Date(value); var y = date.getFullYear(); var m = date.getMonth() + 1; m=(m+'').length==2? m:'0'+m; var d = date.getDate(); d=(d+'').length==2? d:'0'+d; var h=date.getHours(); h=(h+'').length==2? h:'0'+h; var min=date.getMinutes(); min=(min+'').length==2? min:'0'+min; var s=date.getSeconds(); s=(s+'').length==2? s:'0'+s; return y + '-' +m + '-' + d + ' '+ h + ':' +min + ':' + s;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pagehelper 插件注意事项]]></title>
    <url>%2F2018%2F08%2F31%2Fpagehelper%E6%8F%92%E4%BB%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[问题 在用 pagehelper插件 时，遇到了分页数量查询出错的问题。 pagehelper和mybatis的关联结果查询冲突，在GitHub上的重要提示中有写。 解决 后续中找到了一种解决方案。 https://blog.csdn.net/u013887008/article/details/80382764 注:数据量过多时，不推荐使用，还是用一般的分页方式。]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 触发器]]></title>
    <url>%2F2018%2F08%2F29%2Fmysql-%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在ＭySQL中，触发器可以在你执行INSERT、UPDATE或DELETE的时候，执行一些特定的操作。在创建触发器时，可以指定是在执行SQL语句之前或是之后执行这些操作。通过触发器，你可以实现一些业务逻辑或一些数据限制，在简化应用程序逻辑，优化系统性能时非常有用。但在使用MySQL触发器也有一些注意事项，否则会导致触发器不能工作或不按指定的方式工作。 1. MySQL触发器注意事项MySQL触发器使用非常简单，当然其功能也比较有限。当你在项目中大量使用触发器，那么你应该注意以下几点，以避免触发器不按预期效果执行： MySQL触发器能基于行触发，MySQL触发器始终时基于表中的一条记录触发，而不是一组SQL语句。因此，如果需要变动整个数据集而数据集数据量又较大时，触发器效果会非常低。每一个表的一个事件只能定义一个触发器，例如：不能在AFTER INSERT上定义一个以上的触发器。 2. MySQL触发器可能导致的问题由于MySQL触发器基于行触发的特性，因此对于批量操作并不适合使用触发器，如：汇总表、缓存表等。触发器使用不当，可能会导致以下问题： 一个MySQL触发器可能会关联到另外一张表或几张表的操作。因此，会导致数据库服务器负荷也会相应的增加一倍或几倍，如果出现因为触发器问题导致的性能问题，会很难定位问题位置和原因。在基于锁的操作中，触发器可能会导致锁等待或死锁。触发器执行失败，原来执行的SQL语名也会执行失败。而因为触发器导致的失败结果和失败原因，往往很难排查。 3. MySQL触发器的好处对MySQL触发器有足够的认识和了解后，MySQL触发器会给我们带来极大的便利。当实现一些系统约束时，或在实现系统维护及针对操作数据的更新时，使用触发器都非常方便。在之胶我们介绍了MySQL触发器不适合做的一些工作，但MySQL触发器在以下一些应用场景中，会非常实用： 基于行数据变更的日志记录。如：在用户订单系统中，我们可以基于用户订单数据状态的改变，使用触发器构建用户订单日志表数据。 基于行数据变更的关系数据的更新。如：用户订单改变至付款或相关状态时，我们可以基于用户订单数据状态的改变，使用触发器改变用户会付款或相应状态信息。 基于行数据变更的数据汇总。如：用户订单成交或失败，我们可以基于用户订单数据状态的改变，使用触发器构建用户总成交量或失败量汇总数据。 以上仅列举了一些常用场景，合理的利用MySQL触发器会在数据库工作效率和开发效率上有很大的提高。 由于MySQL触发器的种种问题，要求我们在创建触发器就应该充分考虑。避免使用不合适的触发器，并能对所有触发器有足够的了解，以便问题的定位和排查。 特性 有begin end体，begin end;之间的语句可以写的简单或者复杂 什么条件会触发：I、D、U 什么时候触发：在增删改前或者后 触发频率：针对每一行执行 触发器定义在表上，附着在表上 注意 尽量少使用触发器，不建议使用。 假设触发器触发每次执行1s，insert table 500条数据，那么就需要触发500次触发器，光是触发器执行的时间就花费了500s，而insert 500条数据一共是1s，那么这个insert的效率就非常低了。因此我们特别需要注意的一点是触发器的begin end;之间的语句的执行效率一定要高，资源消耗要小。 触发器尽量少的使用，因为不管如何，它还是很消耗资源，如果使用的话要谨慎的使用，确定它是非常高效的：触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器，因为它会非常消耗资源。 语法 1、创建只有一个执行语句的触发器1CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件 ON 表名 FOR EACH ROW 执行语句; 2、创建有多个执行语句的触发器12345CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件ON 表名 FOR EACH ROWBEGIN 执行语句列表END; 例123456CREATE TRIGGER trig2 BEFORE DELETE ON work FOR EACH ROW BEGIN INSERT INTO time VALUES(NOW()); INSERT INTO time VALUES(NOW()); END 3、NEW与OLD详解MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容，具体地： 在INSERT型触发器中，NEW用来表示将要（BEFORE）或已经（AFTER）插入的新数据； 在UPDATE型触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据； 在DELETE型触发器中，OLD用来表示将要或已经被删除的原数据； 另外，OLD是只读的，而NEW则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。 4、查看触发器1234SHOW TRIGGERS;显示所有触发器的基本信息；无法查询指定的触发器。SELECT * FROM information_schema.triggers;显示所有触发器的详细信息；同时，该方法可以查询制定触发器的详细信息。 如果加where，可以写成12select * from information_schema.triggers where trigger_name='tri_insert_order'; 所有触发器信息都存储在information_schema数据库下的triggers表中，可以使用SELECT语句查询，如果触发器信息过多，最好通过TRIGGER_NAME字段指定查询。 5、删除触发器1DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name 删除触发器之后最好使用上面的方法查看一遍；同时，也可以使用database.trig来指定某个数据库中的触发器。 示例在做支付宝订单支付的时，支付宝支付接口在一个单独的项目中，在后台调取接口生成订单去支付，当完成支付时，因为回调方法在另一个项目中，没法修改，只能用触发器来实现对表数据的监控，来完成剩下的业务逻辑。 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142BEGIN DECLARE done INT DEFAULT FALSE ; /*遍历数据结束标志 */ declare lenght_time int(5); /*时长*/ declare column_id varchar(32); /*栏目id*/ /*定义游标 以及赋值*/ declare column_ids cursor for select sod.service_id,sod.duration from sys_order_detail sod where order_id in (SELECT t.order_id FROM sys_order_info t WHERE order_number = NEW.out_trade_no); DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE ;/* 将结束标志绑定到游标 */ IF (NEW.trade_status = 'TRADE_SUCCESS') THEN UPDATE sys_order_info set order_status = '2' where order_number = NEW.out_trade_no; /*打开游标*/ open column_ids ; /*循环开始*/ read_loop:loop /*提前游标的值 */ fetch column_ids into column_id ,lenght_time; /*声明结束的时候*/ if done then leave read_loop ; end if ; /*根据时长和栏目id修改时长*/ UPDATE xypt_column SET end_time = DATE_ADD(end_time, INTERVAL lenght_time MONTH) where id =column_id ; end loop ; /*循环结束*/ close column_ids ;/*关闭游标*/ ELSE UPDATE sys_order_info set order_status = '3' where order_number = NEW.out_trade_no; END IF;END 参考地址点击查看触发器概念 https://itbilu.com/database/mysql/4y77zMXel.html点击查看触发器应用 https://www.cnblogs.com/geaozhang/p/6819648.html点击查看官网示例 https://dev.mysql.com/doc/refman/5.5/en/trigger-syntax.html]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java List接口]]></title>
    <url>%2F2018%2F08%2F29%2Fjava-List%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[介绍Interface List 继承自Collection, Iterable，实现类有AbstractList, AbstractSequentialList, ArrayList, AttributeList, CopyOnWriteArrayList, LinkedList, RoleList, RoleUnresolvedList, Stack, Vector，最常用的实现类是ArrayList。 常用方法概要接口方法 （有描述的为常用方法） 修饰符和返回类型 方法 描述 boolean add(E e) 将指定的元素追加到此列表的末尾（可选操作）。 void add(int index, E element) 将指定的元素插入此列表中的指定位置（可选操作）。 boolean addAll(Collection&lt;? extends E&gt; c) boolean addAll(int index, Collection&lt;? extends E&gt; c) void clear() 从此列表中删除所有元素（可选操作）。 boolean contains(Object o) 如果此列表包含指定的元素，则返回 true 。 boolean containsAll(Collection&lt;?&gt; c) boolean equals(Object o) E get(int index) 返回此列表中指定位置的元素。 int hashCode() 返回此列表的哈希码值。 int indexOf(Object o) 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1 boolean isEmpty() Iterator iterator() int lastIndexOf(Object o) ListIterator listIterator() ListIterator listIterator(int index) E remove(int index) 删除该列表中指定位置的元素（可选操作）。 boolean remove(Object o) 从列表中删除指定元素的第一个出现（如果存在）（可选操作）。 boolean removeAll(Collection&lt;?&gt; c) default void replaceAll(UnaryOperator operator) boolean retainAll(Collection&lt;?&gt; c) E set(int index, E element) 用指定的元素（可选操作）替换此列表中指定位置的元素。 int size() default void sort(Comparator&lt;? super E&gt; c) default Spliterator spliterator() List subList(int fromIndex, int toIndex) Object[] toArray() 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 T[] toArray(T[] a) 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型 list去重方法12345678910111213141516171819202122232425List&lt;String&gt; lst1=new ArrayList&lt;&gt;();lst1.add("aa");lst1.add("dd");lst1.add("ss");lst1.add("aa");lst1.add("ss");//-----------------------------------//方法 1.for (int i = 0; i &lt;lst1.size()-1; i++) &#123; for (int j = lst1.size()-1; j &gt;i; j--) &#123; if (lst1.get(j).equals(lst1.get(i))) &#123; lst1.remove(j); &#125; &#125;&#125;System.out.println(lst1);//-----------------------------------//方法 2.List&lt;String&gt; lst2=new ArrayList&lt;&gt;();for (String s:lst1) &#123; if (Collections.frequency(lst2, s)&lt;1) &#123; lst2.add(s); &#125;&#125;System.out.println(lst2); 参考地址java 官方文档 https://docs.oracle.com/javase/8/docs/api/java/util/List.html中文文档下载]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts 地图统计数据]]></title>
    <url>%2F2018%2F08%2F29%2FECharts-%E5%9C%B0%E5%9B%BE%E7%BB%9F%E8%AE%A1%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div&gt; &lt;div id="main" style="height:400px;width:800px;margin: auto;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- ECharts单文件引入 --&gt; &lt;script src="http://echarts.baidu.com/build/dist/echarts.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 路径配置 require.config(&#123; paths: &#123; echarts: 'http://echarts.baidu.com/build/dist' &#125; &#125;); // 使用 require(['echarts', 'echarts/chart/line', 'echarts/chart/bar', // 使用柱状图就加载bar模块，按需加载 'echarts/chart/map', ], function(ec) &#123; // 基于准备好的dom，初始化echarts图表 var myChart = ec.init(document.getElementById('main')); var option = &#123; title: &#123; text: '访问来访分析', x:"center" /*subtext: '数据来自国家统计局' */ &#125;, tooltip: &#123; trigger: 'item' &#125;, dataRange: &#123; orient: 'horizontal', min: 0, max: 55000, text: ['高', '低'], // 文本，默认为数值文本 splitNumber: 0, x: "20%" &#125;, toolbox: &#123; show: false, orient: 'vertical', x: 'right', y: 'center', feature: &#123; mark: &#123; show: true &#125;, dataView: &#123; show: true, readOnly: false &#125; &#125; &#125;, series: [&#123; name: '累积访问次数', type: 'map', mapType: 'china', mapLocation: &#123; x: 'center' &#125;, itemStyle: &#123; normal: &#123; label: &#123; show: true &#125; &#125;, emphasis: &#123; label: &#123; show: true &#125; &#125; &#125;, data: [ &#123;name:'北京', value:16251.93&#125;, &#123;name:'福建', value:17560.18&#125;, &#123;name:'上海', value:19195.69&#125;, &#123;name:'湖北', value:19632.26&#125;, &#123;name:'湖南', value:19669.56&#125;, &#123;name:'四川', value:21026.68&#125;, &#123;name:'辽宁', value:22226.7&#125;, &#123;name:'河北', value:24515.76&#125;, &#123;name:'河南', value:26931.03&#125;, &#123;name:'浙江', value:32318.85&#125;, &#123;name:'山东', value:45361.85&#125;, &#123;name:'江苏', value:49110.27&#125;, &#123;name:'广东', value:53210.28&#125;] &#125;], animation: false &#125;; // 为echarts对象加载数据 myChart.setOption(option); &#125;); &lt;/script&gt; 效果点击查看 ECharts_demo2.html 参考地址参考地址:http://echarts.baidu.com/echarts2/doc/example/mix3.html]]></content>
      <categories>
        <category>前端</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ECharts 制作折线图/统计图]]></title>
    <url>%2F2018%2F08%2F28%2FECharts-%E5%88%B6%E4%BD%9C%E6%8A%98%E7%BA%BF%E5%9B%BE-%E6%9F%B1%E7%8A%B6%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[官方api官网 http://echarts.baidu.com/examples/官方api http://echarts.baidu.com/api.html#echarts配置项详细介绍 http://echarts.baidu.com/option.html#title 介绍ECharts2.0提供了常规的折线图、柱状图、散点图、饼图、K线图，用于统计的盒形图，用于地理数据可视化的地图、热力图、线图，用于关系数据可视化的关系图、treemap、旭日图，多维数据可视化的平行坐标，还有用于 BI 的漏斗图，仪表盘，并且支持图与图之间的混搭。ECharts 3 开始加强了对多维数据的支持。 直接贴代码以下部分配置项注释已加，还需要配置其他请查看配置项详细介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;ECharts&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;&lt;div&gt; &lt;div id="main" style="height:400px;width:800px;margin: auto;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;!-- ECharts单文件引入 --&gt;&lt;script src="http://echarts.baidu.com/build/dist/echarts.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;// 路径配置require.config(&#123; paths: &#123; echarts: 'http://echarts.baidu.com/build/dist' &#125;&#125;);// 使用require( [ 'echarts', 'echarts/chart/line' , 'echarts/chart/bar', // 使用柱状图就加载bar模块，按需加载 ],function (ec) &#123; // 基于准备好的dom，初始化echarts图表 var myChart = ec.init(document.getElementById('main')); var option = &#123; title : &#123;//标题 text: '一周内流量统计变化', x:'center', //此处使用 left:"center",textAlign:"center"均不可用， //换成x后才好使，下面的同理 &#125;, tooltip: &#123; //提示框 show: true, trigger: 'axis' //坐标轴触发 &#125;, toolbox: &#123; //工具箱 show: true, //是否展示按钮 x:'left', feature: &#123; magicType: &#123; //模式切换（折线图，柱状图） type: ['line', 'bar', ], show: true &#125;, dataZoom: &#123; //区域放大 show: true &#125;, dataView: &#123; //数据视图 show: true &#125;, restore: &#123; //还原按钮 show: true &#125;, saveAsImage: &#123; //保存图片按钮 show: true &#125; &#125; &#125;, legend: &#123; //名称 data:['统计',"累计"], y:'8%', &#125;, xAxis : [ //x轴数据 &#123; type : 'category', //分类 boundaryGap : true, //数据边界线 data : ['2018-08-21','2018-08-22', '2018-08-23','2018-08-24', '2018-08-25','2018-08-26', '2018-08-27'] &#125; ], yAxis : [ //y轴数据 &#123; type : 'value' &#125; ], series : [ &#123; "name":"统计", "type":"line", "data":[5, 20, 40, 10, 10, 20,55] &#125;, &#123; "name":"累计", "type":"line", "data": [0,21,15,6,0,0,3] &#125; ] &#125;; // 为echarts对象加载数据 myChart.setOption(option); &#125;);&lt;/script&gt;&lt;/body&gt; 效果点击查看效果 ECharts_demo.html 参考地址参考地址:http://echarts.baidu.com/echarts2/doc/example/line2.html]]></content>
      <categories>
        <category>前端</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>echarts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysqlql计算一段时间内 表中每天的数据量]]></title>
    <url>%2F2018%2F08%2F27%2Fmysqlql%E8%AE%A1%E7%AE%97%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E5%86%85-%E8%A1%A8%E4%B8%AD%E6%AF%8F%E5%A4%A9%E7%9A%84%E6%95%B0%E6%8D%AE%E9%87%8F%2F</url>
    <content type="text"><![CDATA[原sql为12345678910111213141516171819202122 SELECT CAST(tt.startTime AS char) x,count(tt.id) yFROM ( SELECT t.id id, date(t.start_time) startTime FROM sys_visit_log t WHERE t.prod_id IN ( SELECT xp.id FROM xypt_production xp WHERE xp.org_id = #&#123;orgId,jdbcType=VARCHAR&#125; ) ) ttwhere tt.startTime &amp;lt; date(NOW()) and tt.startTime &amp;gt;= date( DATE_SUB(NOW(), INTERVAL 7 DAY))GROUP BY startTimeORDER BY tt.startTime ASC 结果12342018-08-20 162018-08-22 212018-08-23 152018-08-24 6 修改后改为1234567891011121314151617181920212223242526272829303132333435363738SELECT CAST(a.x AS CHAR) x, count(tt.id) yFROM ( SELECT date( DATE_SUB(NOW(), INTERVAL 1 DAY) ) x UNION ALL SELECT date( DATE_SUB(NOW(), INTERVAL 2 DAY) ) x UNION ALL SELECT date( DATE_SUB(NOW(), INTERVAL 3 DAY) ) x UNION ALL SELECT date( DATE_SUB(NOW(), INTERVAL 4 DAY) ) x UNION ALL SELECT date( DATE_SUB(NOW(), INTERVAL 5 DAY) ) x UNION ALL SELECT date( DATE_SUB(NOW(), INTERVAL 6 DAY) ) x UNION ALL SELECT date( DATE_SUB(NOW(), INTERVAL 7 DAY) ) x ) aLEFT JOIN ( SELECT t.id id, date(t.start_time) startTime FROM sys_visit_log t WHERE t.prod_id IN ( SELECT xp.id FROM xypt_production xp WHERE xp.org_id = 'a4b1ccf70e4c47978e7931356ab43577' ) AND date(t.start_time) &lt; date(NOW()) AND date(t.start_time) &gt;= date( DATE_SUB(NOW(), INTERVAL 7 DAY) )) tt ON a.x = tt.startTimeGROUP BY a.xORDER BY a.x ASC 结果12345672018-08-20 162018-08-21 02018-08-22 212018-08-23 152018-08-24 62018-08-25 02018-08-26 0 参考地址https://stackoverflow.com/questions/16636433/mysql-count-to-return-0-if-no-records-found]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis坑点]]></title>
    <url>%2F2018%2F08%2F27%2Fmybatis%E5%9D%91%E7%82%B9%2F</url>
    <content type="text"><![CDATA[问题Mybatis出错：Error instantiating class xxx with invalid types () or values () 解决原因是JavaBean必须要有无参构造器 mybatis在创建bean映射的时候需要无参的构造其来构造对象，然后才进行赋值操作。 因此，Bean必须要有无参构造函数才能正确映射。]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[d3制作折线图]]></title>
    <url>%2F2018%2F08%2F27%2Fd3%E5%88%B6%E4%BD%9C%E6%8A%98%E7%BA%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 &lt;style&gt; .container &#123; margin: 30px auto; width: 600px; height: 300px; border: 1px solid #000; &#125; .axis path, .axis line, .line &#123; stroke: #000; fill: none; &#125; &lt;/style&gt;&lt;div class="tablebox"&gt; &lt;div class="container"&gt; &lt;svg width="100%" height="100%"&gt;&lt;/svg&gt; &lt;/div&gt; &lt;script src="http://d3js.org/d3.v3.min.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; window.onload = function() &#123; var width = 600, height = 300; // SVG画布边缘与图表内容的距离 var padding = &#123; top: 50, right: 50, bottom: 70, left: 50 &#125;; // 创建一个分组用来组合要画的图表元素 var main = d3.select('.container svg').append('g') .classed('main', true) .attr('transform', "translate(" + padding.top + ',' + padding.left + ')'); // 模拟数据 var dataset = [ &#123;x: '2018-01-01', y: 11&#125;, &#123;x: '2018-01-02', y: 35&#125;, &#123;x: '2018-01-03', y: 23&#125;, &#123;x: '2018-01-04', y: 78&#125;, &#123;x: '2018-01-05', y: 55&#125;, &#123;x: '2018-01-06', y: 18&#125;, &#123;x: '2018-01-07', y: 98&#125;, &#123;x: '2018-01-08', y: 100&#125;, &#123;x: '2018-01-09', y: 22&#125;, &#123;x: '2018-01-10', y: 65&#125; ]; // 创建x轴的比例尺(线性比例尺) var format = d3.time.format("%Y-%m-%d"); /* var xScale = d3.scale.linear() .domain(d3.extent(dataset, function(d) &#123; return d.x; &#125;)) .range([0, width - padding.left - padding.right]);*/ var xScale = d3.time.scale() .domain([format.parse(dataset[0].x), format.parse(dataset[dataset.length-1].x)]) .range([0, width - padding.left - padding.right]); // 创建y轴的比例尺(线性比例尺) var yScale = d3.scale.linear() .domain([0, d3.max(dataset,function(d) &#123; return d.y; &#125;)]) .range([height - padding.top - padding.bottom, 0]); // 创建x轴 var xAxis = d3.svg.axis() .scale(xScale) .orient('bottom') .tickFormat(d3.time.format("%Y-%m-%d")); // 创建y轴 var yAxis = d3.svg.axis() .scale(yScale) .orient('left'); // 添加SVG元素并与x轴进行“绑定” main.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + (height - padding.top - padding.bottom) + ')') .call(xAxis) .selectAll("text") .attr("transform", "rotate(-70)") .style("text-anchor", "end"); ; // 添加SVG元素并与y轴进行“绑定” main.append('g') .attr('class', 'axis') .call(yAxis); // 添加折线 var line = d3.svg.line() .x(function(d) &#123; return xScale(format.parse(d.x)) &#125;) .y(function(d) &#123; return yScale(d.y); &#125;) // 选择线条的类型 .interpolate('linear'); // 添加path元素，并通过line()计算出值来赋值 main.append('path') .attr('class', 'line') .attr('d', line(dataset)); // 添加点 main.selectAll('circle') .data(dataset) .enter() .append('circle') .attr('cx', function(d) &#123; return xScale(format.parse(d.x)); &#125;) .attr('cy', function(d) &#123; return yScale(d.y); &#125;) .attr('r', 5) .attr('fill', function(d, i) &#123; return getColor(i); &#125;); &#125;; function getColor(idx) &#123; var palette = [ '#2ec7c9', '#b6a2de', '#5ab1ef', '#ffb980', '#d87a80', '#8d98b3', '#e5cf0d', '#97b552', '#95706d', '#dc69aa', '#07a2a4', '#9a7fd1', '#588dd5', '#f5994e', '#c05050', '#59678c', '#c9ab00', '#7eb00a', '#6f5553', '#c14089' ] return palette[idx % palette.length]; &#125; &lt;/script&gt;&lt;/div&gt; 结果点击查看 d3_demo.html 另外一个随机多折线demo d3_demo2.html 使用ECharts.js 制作折线图请点击访问ECharts.js 制作折线图 参考地址d3制作折线图横坐标轴为日期日期转换问题刻度数多折线]]></content>
      <categories>
        <category>前端</category>
        <category>数据可视化</category>
      </categories>
      <tags>
        <tag>d3</tag>
        <tag>js</tag>
        <tag>折线图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea使用指南]]></title>
    <url>%2F2018%2F08%2F23%2Fidea%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[项目运行时 自动编译更新项目https://blog.csdn.net/wangyy130/article/details/70901589 idea激活idea activate license server地址：https://blog.csdn.net/u013218587/article/details/80590878 1234567891011121314151617http://idea.toocruel.nethttp://idea.youbbs.orghttp://idea.congm.inhttp://im.js.cn:8888http://intellij.mandroid.cn/http://idea.imsxm.com/http://idea.iteblog.com/key.phphttp://xdouble.cn:8888/http://hb5.s.osidea.cc:1017]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[excel转html在线工具]]></title>
    <url>%2F2018%2F08%2F23%2Fexcel%E8%BD%AChtml%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[链接地址：http://pressbin.com/tools/excel_to_html_table/index.html 解决方案123在makedowm中，设计表格可能会遇到需要合并两个表格的情况，但是makedown只能制作简单的表格，这时就需要直接写成html格式。在朋友的提示下，找到了一个可以把excel直接转换为html的工具。直接从excel中复制内容进来，点击 conver进行转换，然后进行修改。 缺陷1虽然这种方法可以解决问题，但是makedown原本目的是为了让文本简洁可读高效，违背了makedown的初衷，不建议用这种方式]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring 定时任务]]></title>
    <url>%2F2018%2F08%2F23%2Fspring-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[可基于注解，也可基于配置 1.在配置文件中配置定时任务spring配置文件中，添加命名空间1234在&lt;beans &gt;中添加xmlns:task="http://www.springframework.org/schema/task" http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.2.xsd xml添加配置12345678910111213141516171819202122232425&lt;!-- 定时任务 （将类注入xml）--&gt;&lt;bean id="jobBean" class="com.bxj.common.task.ClearOrderTask" /&gt;&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject" ref="jobBean" /&gt; &lt;!--ClearOrderTask类中需要执行的方法--&gt; &lt;property name="targetMethod" value="doClearOrder" /&gt; &lt;!--将并发设置为false--&gt; &lt;property name="concurrent" value="false" /&gt;&lt;/bean&gt;&lt;bean id="clearOrderTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="jobDetail" /&gt; &lt;!--表达式，每天晚上23点55分开始 执行一次 （可以自定义，谷歌关键词 cron表达式） --&gt; &lt;property name="cronExpression" value="0 55 23 * * ?" /&gt;&lt;/bean&gt;&lt;!--总管理类如果将lazy-init='false'那么容器启动就会执行调度程序 --&gt;&lt;bean id="orderQuertz" class="org.springframework.scheduling.quartz.SchedulerFactoryBean" lazy-init="false" &gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;!--作业调度器,list下可加入其他的调度器 --&gt; &lt;ref bean="clearOrderTrigger" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 执行方法12345678910111213141516171819202122 public class ClearOrderTask &#123; /** * 调度任务开关 */ @Value("$&#123;CLEAR_ORDER_TASK_SWITCH&#125;") private String CLEAR_ORDER_TASK_SWITCH; @Autowired private OrderInfoService orderInfoService; @Autowired private OrderDetailService orderDetailService; @Transactional public void doClearOrder() throws Exception&#123; //检查配置文件任务开关 if( Const.TASK_SWITCH_ON.equals( CLEAR_ORDER_TASK_SWITCH ))&#123; //清除订单 //先删除订单明细 orderDetailService.deleteOrderDetailByTask(); //再删除订单 orderInfoService.deleteOrderInfoByTask();; &#125; &#125; &#125; 2.注解配置定时任务123456789101112131415161718@Componentpublic class MyTask2 &#123; /** * 定时计算。每天凌晨 01:00 执行一次 */ @Scheduled(cron = "0 0 1 * * *") public void show() &#123; System.out.println("show method 2"); &#125; /** * 启动时执行一次，之后每隔2秒执行一次 */ @Scheduled(fixedRate = 1000*2) public void print() &#123; System.out.println("print method 2"); &#125;&#125; 定时任务和cron表达式相关链接参考链接在线cron表达式生成器cron表达式详解]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome 上传下载时卡死问题]]></title>
    <url>%2F2018%2F08%2F23%2Fchrome-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E6%97%B6%E5%8D%A1%E6%AD%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[原因和解决办法1搜狗输入法与chrome冲突，搜狗卸载重新安装就好了。 近期遇到这种问题，将chrome重新安装了好多次都没用。装成低版本的chrome时就好了，但是因为版本太低，好多插件不起效，用起来还是蛋疼。然后在网上找原因时，看到有说可能与搜狗有关系，卸载搜狗后，chrome恢复正常， 重新安装成新版本的搜狗后，问题解决 参考地址:http://tieba.baidu.com/p/5782771456]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 日期操作函数]]></title>
    <url>%2F2018%2F08%2F22%2Fmysql-%E6%97%A5%E6%9C%9F%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[DATE_ADD()：日期增加函数DATE_SUB()：日期减少函数 示例添加15分钟到日期并返回日期：1SELECT DATE_ADD("2018-08-22 09:34:21", INTERVAL 15 MINUTE); 从日期减去10天并返回日期：1SELECT DATE_SUB("2018-08-22", INTERVAL 10 DAY); 定义和用法123456_定义：_DATE_ADD（）函数在添加特定时间/日期间隔后返回日期。DATE_SUB（）函数在减去某个时间/日期间隔后返回一个日期。__用法：__DATE_ADD(date, INTERVAL value unit)DATE_SUB(date, INTERVAL value unit) 参数值 参数 说明 date 必填，原日期 value 必填，增加/减去日期的值 unit 必填，单位类型 unit值 参数 说明 MICROSECOND 微秒 SECOND 秒 MINUTE 分钟 HOUR 小时 DAY 天 WEEK 周 MONTH 月 QUARTER 季度 YEAR 年 SECOND_MICROSECOND 秒.微秒 MINUTE_MICROSECOND 分钟.微秒 MINUTE_SECOND 分钟.秒 HOUR_MICROSECOND 小时.微秒 HOUR_SECOND 小时.秒 HOUR_MINUTE 小时.分 DAY_MICROSECOND 天.微秒 DAY_SECOND 天.秒 DAY_MINUTE 天.分 DAY_HOUR 天.时 YEAR_MONTH 年.月 参考地址DATE_ADD()参考地址1: https://www.w3schools.com/sql/func_mysql_date_add.aspDATE_SUB()参考地址2: https://www.w3schools.com/sql/func_mysql_date_sub.asp DATE_FORMAT() 函数DATE_FORMAT():不同的格式显示日期/时间数据 示例执行以下脚本1234select DATE_FORMAT(NOW(),'%b %d %Y %h:%i %p'); select DATE_FORMAT(NOW(),'%Y-%m-%d');select DATE_FORMAT(NOW(),'%d %b %y');select DATE_FORMAT(NOW(),'%d %b %Y %T:%f'); 结果1234567891011Aug 28 2018 12:53 AM2018-08-2828 Aug 1828 Aug 2018 12:53:40:000000``` ### 定义和用法``` bash_定义：_DATE_FORMAT() 函数用于以不同的格式显示日期/时间数据。__用法：__DATE_FORMAT(date,format) 参数值date 参数是合法的日期。format 规定日期/时间的输出格式。 format 可用格式 格式 描述 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 参考地址DATE_FORMAT()参考地址1: http://www.w3school.com.cn/sql/func_date_format.asp]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订单支付遇到的问题]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%94%AF%E4%BB%98%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[问题描述前提：是这样的，一笔订单下单之后，如果不支付，会处于待支付状态。而一般这个订单会有类似 30 分钟不支付自动取消订单的功能。 实现：这种功能的实现，可以通过定时任务，每隔 30 秒或一分钟扫描一次。但如果集群环境下，可能定时任务会执行重复。当然我们可以通过类似操作系统 PV 操作限制同一时段只能一个定时任务执行。 目标：这种情况，除了定时任务，还有没有其他好点的实现？ 解决办法1.记录下单时间 。在用户访问订单的时候用超时时间和下单时间比较，如果超时就取消订单，用户主动触发。在加上定时任务，扫描表，过期订单改为取消状态。优点：方法简单高效缺点：用户自己触发的这种并不能即使恢复库存.2.利用redis。将订单存入redis中，给订单设置过期时间（expire ）。支付时，去redis查询订单，不存在的话讲订单设置为已取消。 3.延时队列。 可以 rabbitmq 实现的。AB 两个队列，A 队列设置消息过期时间，A 队列没有消费者，A 队列过期后自动转发到 B 队列，B 队列消费者进行取消队列。（此处是别人给的方案，对消息队列熟悉，等有时间研究）]]></content>
      <categories>
        <category>业务</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建]]></title>
    <url>%2F2018%2F08%2F22%2Fhexo%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这是一篇用于记录hexo搭建的日志,用于记录遇到的所有问题: 搭建 hexo搭建：https://zhuanlan.zhihu.com/p/25729240 标签和分类 tags和categories用法：https://github.com/hexojs/hexo/issues/320 增加搜索功能 增加搜索功能：http://www.itfanr.cc/2017/10/27/add-search-function-to-hexo-blog/ 增加本站访问统计次数使用了不蒜子 插件:http://ibruce.info/2015/04/04/busuanzi/ 修改hemes/你的主题/layout/_partial/footer.ejs文件123456789101112131415161718192021&lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;div class="copyright" &gt; &#123;% set current = date(Date.now(), "YYYY") %&#125; &amp;copy; &#123;% if theme.since and theme.since != current %&#125; &#123;&#123; theme.since &#125;&#125; - &#123;% endif %&#125; &lt;span itemprop="copyrightYear"&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt; &lt;span class="with-love"&gt; &lt;i class="fa fa-&#123;&#123; theme.authoricon &#125;&#125;"&gt;&lt;/i&gt; &lt;/span&gt; &lt;span class="author" itemprop="copyrightHolder"&gt;&#123;&#123; config.author &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;div class="powered-by"&gt;&lt;i class="fa fa-user-md"&gt;&lt;/i&gt;&lt;span id="busuanzi_container_site_uv"&gt; 本站访客数:&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;&lt;/div&gt;&lt;div class="theme-info"&gt;&lt;span id="busuanzi_container_site_pv"&gt; 本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;/div&gt; 我这里去掉了 “由 Hexo 强力驱动 | 主题 - NexT.Gemini“字样 hexo 部署后，绑定域名清空的问题 hexo 部署后 git项目的 Custom domain清空：在source文件夹下面建个CNAME文件夹，里面写上自己的域名，同样的，favicon.ico也可以在里面设置。 参考： https://www.zhihu.com/question/28814437]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode简单难度题解法]]></title>
    <url>%2F1990%2F01%2F01%2Fleetcode%E7%AE%80%E5%8D%95%E9%9A%BE%E5%BA%A6%E9%A2%98%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&lt;!https://leetcode-cn.com&gt; 1. 两数之和 https://leetcode-cn.com/problems/two-sum/ 难度：☆☆ 题目&lt;!https://leetcode-cn.com/articles/two-sum/&gt;: 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。123给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 自己解法123456789101112131415public int[] twoSum(int[] nums, int target) &#123; int[] x=new int[2]; for(int i=0;i&lt;nums.length;i++) &#123; for(int j=nums.length-1;j&gt;=0;j--) &#123; if(nums[i]+nums[j]==target &amp;&amp; i!=j) &#123; x[0]=i;x[1]=j; return x; &#125; &#125; &#125; throw new Exception(&quot;没有符合条件的数&quot;);;&#125; 最优解法1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;);&#125; 1.1 求数字的根 有趣的题目&lt;来自知乎&gt;求一个十进制数字的根1f(12345) -&gt; 1+2+3+4+5 =15 -&gt; 1+5=6 12345的根为6 数学公式写法 123function f(n)&#123; return (n-1)%9 +1 ;&#125; 解释：ab写成：10a+b=9a+a+b，这和a+b相差 9a，也就是9的倍数。如果大一点也是一样，abc写成：100a+10b+c=99a+9b+a+b+c,和a+b+c相差9的倍数99a+9b=9（11a+b）。所以abcde…把所有的位数相加结果就是9的倍数取余。abcde=10000a+1000b+100c+10d+e=9999a +a+ 999b+ b+99c+c +9d +d +e = 9999a +999b +99c +9d +a+b+c+d+e 另外先减一再加一的原因结果不会等于0，如果可以被9整除，直接取余就会是0,这样在计算过程中，先保证所有位数相加是取余是0-8，这样在结果+1时候，就会是1-9.不会出现0值。非常完美的数学算法这里 之所以写成(n-1)%9 +1 不写成 n %9 ，是要改变返回值的值域。(n-1)%9 +1 的值域是 [1,9] ,n %9的值域是[0,8];f(n) =n%9 2. 两数相加 https://leetcode-cn.com/problems/add-two-numbers/ 难度：☆☆☆☆☆给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 自己第一次未解出来 自己看过解析后，重新做的解答123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * public class &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int temp=0; ListNode result=new ListNode(0); result.next=new ListNode(0); ListNode tempNode= result.next; while(l1!=null||l2!=null)&#123; int a =0,b=0; if(l1==null)&#123;a=0;&#125;else&#123;a=l1.val;&#125; if(l2==null)&#123;b=0;&#125;else&#123;b=l2.val;&#125; int i = a+b+temp; int j=i%10; tempNode.next=new ListNode(j ); if(i&gt;=10 )&#123;temp=1; &#125;else&#123;temp=0;&#125; if(l1!=null) &#123;l1=l1.next;&#125; if(l2!=null) &#123;l2=l2.next;&#125; tempNode=tempNode.next; &#125; if(temp==1)&#123; tempNode.next=new ListNode(1); &#125; return result.next.next; &#125;&#125; 标准答案123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0); ListNode p = l1, q = l2, curr = dummyHead; int carry = 0; while (p != null || q != null) &#123; int x = (p != null) ? p.val : 0; int y = (q != null) ? q.val : 0; int sum = carry + x + y; carry = sum / 10; curr.next = new ListNode(sum % 10); curr = curr.next; if (p != null) p = p.next; if (q != null) q = q.next; &#125; if (carry &gt; 0) &#123; curr.next = new ListNode(carry); &#125; return dummyHead.next;&#125; 自己问题难点：没有理解ListNode代表的含义，对链表类的对象没有操作经验。new ListNode(x) 表示的是当前位数上的数字为X,new ListNode(x).next,表示的是下一位上的数字。 自己考虑到了10位进1，后面位数上为null的情况，但是不知道怎么使用代码写出来。这里可以给l1 ,l2 重新赋值临时变量，他的下一位在赋值给他本身。第一个dummyHead是需要返回的值。用curr来表示他的属性，不断的往后赋值，但是不会改变dummyHead对象本身。这里需要注意的是，两位数加两位数可能等于三位数，这里在最后就要多加一次carry值的判断。 3.宝石与石头 https://leetcode-cn.com/problems/jewels-and-stones/comments/ 难度：☆给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此”a”和”A”是不同类型的石头。示例 1:12输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;输出: 3 自己的解法1234567891011121314class Solution &#123; public int numJewelsInStones(String J, String S) &#123; int x=0; byte[] sArray=S.getBytes(); for(int i=0;i&lt;sArray.length;i++) &#123; if(J.indexOf(sArray[i])!=-1) &#123; x++; &#125; &#125; return x; &#125;&#125; 此题暂时没有最优解法。可自由发挥。 4. 回文数 https://leetcode-cn.com/problems/palindrome-number/ 难度：☆☆判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。示例 1:12输入: 121输出: true 自己的解法1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x&lt;0) return false; if(x&gt;=0)&#123; String y=x+&quot;&quot;; byte[] yArray =y.getBytes(); boolean flag=true; for(int i=0;i&lt;yArray.length;i++)&#123; if(yArray[i]!=yArray[yArray.length-i-1])&#123; flag=false; &#125; &#125; return flag; &#125; return false; &#125;&#125; 4.1 上述回文数中 不使用字符串该如何解决 难度：☆☆☆☆☆解析：不使用字符串，首先想到的是，是否有现成的数据公示可以用，想了想，目前接触的没有可以用的，只能想想其他方法。因为数字的特殊性，在程序中经常用到，想一想是否能否算出各个位数上的数字。比如12345，长度可以用12345/(10^i)算出来。要计算12345的第三位上的数字。 可以先用12345减去第三位前面的数字，再除以10^2，取整数。即可算出第三位上的数字。第三位前面的数字如何计算。 可以用12345 除以10^3，取整数，再乘以10^3，即可算出 第三位前面的数字为 12000。用12345减去 12000 为345。 345 除以10^2，取整为3。这样就可以算出各个位数上的数字。再用来比较就可以了。 自己解法123456789101112131415161718192021222324252627 public static boolean isPalindrome(int x) &#123; if(x&lt;0) return false; if(x&lt;10) return true; //计算出x长度 int y=0; for(int j=1;j&lt;22;j++)&#123; int temp=(int) (x/(Math.pow(10,j))); if(temp&gt;0&amp;&amp;temp&lt;10)&#123; y=j+1; &#125; &#125; boolean flag=true; for(int i=1;i&lt;=y;i++)&#123; //第i位数字 int tempA1=(int) (x/(Math.pow( 10,i))); int after= (int) ( (x- tempA1 *(Math.pow( 10,i)))/(Math.pow( 10,i-1)) ); // //第y-i-1位数字(倒数i位数字) int tempB1=(int) (x/( Math.pow( 10,(y-i+1)))); int before= (int) ( (x- tempB1 *(Math.pow( 10,(y-i+1))))/(Math.pow( 10,(y-i-1+1))) ); if(before == after)&#123; //flag=true; &#125; else &#123; flag=false; &#125; &#125; return flag;&#125; 4.2 软通笔试题长度为n的数组乱序存放着0至n-1. 现在只能进行0与其他数的交换，完成以下函数 1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; /** * 交换数组里n和0的位置 * * @param array * 数组 * @param len * 数组长度 * @param n * 和0交换的数 */ // 不要修改以下函数内容 public void swapWithZero(int[] array, int len, int n) &#123; Main.SwapWithZero(array, len, n); &#125; // 不要修改以上函数内容 /** * 通过调用swapWithZero方法来排 * * @param array * 存储有[0,n)的数组 * @param len * 数组长度 */ public void sort(int[] array, int len) &#123; // 完成这个函数 for(int i = len-1;i&gt;=0; i--)&#123; if(array[i] == i) //判断是否在正确位置 continue; swapWithZero(array,len,array[i]); swapWithZero(array,len,i); &#125; &#125;&#125;``` 在网上看到有人说为什么要用swapWithZero()这个方法，直接赋值更快，如下： for(int i = 0; i &lt; len; i++){ array[i]=i; }`]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
